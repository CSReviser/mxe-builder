[ 70%] Building CXX object CMakeFiles/CaptureStream2.dir/settings.cpp.o
/home/kazuo/cs/CaptureStream2/settings.cpp: In member function ‘void Settings::initDefaultSaveFolder()’:
/home/kazuo/cs/CaptureStream2/settings.cpp:325:18: error: ‘QStandardPaths’ has not been declared
  325 |     saveFolder = QStandardPaths::writableLocation(QCoreApplication::applicationDirPath());
      |                  ^~~~~~~~~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:239: CMakeFiles/CaptureStream2.dir/settings.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2




QString folder = runtime.saveFolder;
QString ffmpeg = runtime.ffmpegFolder;
QString ext    = runtime.audioExtension;





optional[i].id = QString(s.ids[p.keyId]);
optional[i].label = QString(s.labels[p.keyLabel]);


optional[i].id = s.ids.value(p.keyId, QString());
optional[i].label = s.labels.value(p.keyLabel, QString());


DownloadThread内で

	RuntimeConfig runtime;
	runtime.applySettings(settings);
	
	optional1 = runtime.optional[0].id;
	optional2 = runtime.optional[1].id;
	optional3 = runtime.optional[2].id;
	optional4 = runtime.optional[3].id;
	optional5 = runtime.optional[4].id;
	optional6 = runtime.optional[5].id;
	optional7 = runtime.optional[6].id;
	optional8 = runtime.optional[7].id;
	special1 = runtime.spec[0].id;
	special2 = runtime.spec[1].id;
	special3 = runtime.spec[2].id;
	special4 = runtime.spec[3].id;




std::unique_ptr<RuntimeConfig> runtime;

runtime = std::make_unique<RuntimeConfig>();
runtime->applySettings(settings);
runtime->applyGui(gui);

downloadThread = new DownloadThread(Settings::instance(), runtime.get(), ui);





const ProgramEntry &optionalProgram(int index) const {
    return optional[index];
}

const ProgramEntry &specProgram(int index) const {
    return spec[index];
}

optional1 = runtime.optionalProgram(0).id;
optional2 = runtime.optionalProgram(1).id;
optional3 = runtime.optionalProgram(2).id;
optional4 = runtime.optionalProgram(3).id;
optional5 = runtime.optionalProgram(4).id;
optional6 = runtime.optionalProgram(5).id;
optional7 = runtime.optionalProgram(6).id;
optional8 = runtime.optionalProgram(7).id;

special1 = runtime.specProgram(0).id;
special2 = runtime.specProgram(1).id;
special3 = runtime.specProgram(2).id;
special4 = runtime.specProgram(3).id;




guistate.h

#pragma once
#include <QMap>
#include <QString>

class MainWindow;

struct GuiState
{
    QMap<QString,bool> flags;

    static GuiState fromMainWindow(const MainWindow& w);
};



guistate.cpp

#include "guistate.h"
#include "mainwindow.h"
#include "constants_flag.h"

GuiState GuiState::fromMainWindow(const MainWindow& w)
{
    GuiState s;

    // FlagTableを使って全部まとめて収集
    for (int i = 0; i < Constants::FlagCount; ++i) {
        const auto &f = Constants::FlagTable[i];
        s.flags[f.keyFlag] = w.guiFlagValue(f.keyFlag);
    }

    return s;
}

bool guiFlagValue(const QString& key) const;

bool MainWindow::guiFlagValue(const QString& key) const
{
    if (key == KEY_LAST_WEEK)   return ui->checkLastWeek->isChecked();
    if (key == KEY_PROGRAM_LIST)return programListMode;
    if (key == KEY_NOGUI)       return false; // GUIでは常にfalse

    return false;
}

void RuntimeConfig::applyGui(const GuiState& g)
{
    for (auto it = g.flags.begin(); it != g.flags.end(); ++it) {
        setFlag(it.key(), it.value());
    }
}

void MainWindow::onRun()
{
    GuiState gui = GuiState::fromMainWindow(*this);

    RuntimeConfig rc;
    rc.applySettings(settings);
    rc.applyCommandLine(cli);
    rc.applyGui(gui);

    runner.start(rc);
}







void Settingsdialog::pushbutton_2()
{
    QStringList labels;

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        auto &repo = ProgramRepository::instance();
        labels << repo.id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + labels[0] + "\n" +
        "２：" + labels[1] + "\n" +
        "３：" + labels[2] + "\n" +
        "４：" + labels[3];

    if (QMessageBox::question(this, tr("特別番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::PRESET_SIZE; ++i)
            settings.specials[i] = edits[i]->text();
    }
}


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // ★ 番組一覧の初期化（非同期）
    auto &repo = ProgramRepository::instance();
    repo.updatePrograms();

    // ★ 番組一覧更新後に UI を更新したい場合
    connect(&repo, &ProgramRepository::programListUpdated,
            this, &MainWindow::onProgramListUpdated);
}

Settingsdialog::Settingsdialog(Settings& ini, QWidget *parent)
    : QDialog(parent), ui(new Ui::Settingsdialog), settings(ini)


auto &repo = ProgramRepository::instance();
repo.name_map
repo.id_map
repo.thumbnail_map


auto &repo = ProgramRepository::instance();
if (repo.id_map.isEmpty()) {
    QMessageBox::warning(this, "情報取得中", "番組一覧を取得中です。しばらくお待ちください。");
    return;
}






private:
    static QString iniFilePath();


QString Settings::iniFilePath()
{
#ifdef Q_OS_MACOS
    QString dir =
        QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);
    return dir + QDir::separator() + Constants::IniFileName;
#else
    QString dir = QCoreApplication::applicationDirPath();
    return dir + QDir::separator() + Constants::IniFileName;
#endif
}

void Settings::load()
{
    QSettings ini(iniFilePath(), QSettings::IniFormat);


void Settings::save()
{
    QSettings ini(iniFilePath(), QSettings::IniFormat);



1. macOS飲みiniファイルの保存パスが異なる。という仕様が漏れていたので追加が必要。
2.iniファイルの保存先はsettingsが持ち役割で良いか？
3.load/saveで使えるように共通関数にしたい。

#ifdef Q_OS_MACOS
	QString result = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation) + "/";
	result += QDir::separator();
	ini_file_path = result + Constants::IniFileName;
#endif
#if !defined( Q_OS_MACOS )
	QString result = QCoreApplication::applicationDirPath();
	result += QDir::separator();
	ini_file_path = result + Constants::IniFileName;
#endif	


save側の現在
void Settings::saveProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    ini.setValue(p.keyChecked, checked[p.keyChecked]);

    if (!qs(p.keyId).isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!qs(p.keyLabel).isEmpty())
        ini.setValue(p.keyLabel, labels[p.keyLabel]);
}

上記を下記に書き換える
void Settings::saveProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked
    ini.setValue(p.keyChecked, checked[p.keyChecked]);

    // id
    if (p.saveId)
        ini.setValue(p.keyId, ids[p.keyId]);

    // label
    if (p.saveLabel)
        ini.setValue(p.keyLabel, labels[p.keyLabel]);
}

void Settings::loadProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id
    if (p.hasId) {
        if (p.saveId) {
            ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();
        } else {
            ids[p.keyId] = QString::fromUtf8(p.idDefault);
        }
    }

    // label
    if (p.hasLabel) {
        if (p.saveLabel) {
            labels[p.keyLabel] = ini.value(p.keyLabel, p.labelDefault).toString();
        } else {
            labels[p.keyLabel] = QString::fromUtf8(p.labelDefault);
        }
    }
}



struct ProgramDefinition {
    enum class Kind {
        English,
        Optional,
        Spec,
        Feature
    };

    Kind kind;

    const char* keyChecked;
    bool checkedDefault;

    const char* keyId;
    const char* idDefault;
    bool hasId;

    const char* keyLabel;
    const char* labelDefault;
    bool hasLabel;

    const char* objectName;
};


void Settings::loadProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked（必須）
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id（存在する場合のみ）
    if (p.hasId) {
        ids[p.keyId] =
            ini.value(p.keyId, p.idDefault).toString();
    }

    // label（存在する場合のみ）
    if (p.hasLabel) {
        labels[p.keyLabel] =
            ini.value(p.keyLabel, p.labelDefault).toString();
    }
}





void Settings::loadProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id
    if (!qs(p.keyId).isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // label
    if (!qs(p.keyLabel).isEmpty())
        labels[p.keyLabel] = ini.value(p.keyLabel, p.labelDefault).toString();
}



struct ProgramDefinition {
    enum class Kind {
        English,   // 固定番組
        Optional,  // 任意設定番組
        Spec,      // 特番
        Feature    // チェックボックス
    };

    Kind kind;

    // checked の保存キーとデフォルト値
    const char* keyChecked;
    bool    checkedDefault;

    // id の保存キーとデフォルト値（English/Feature は空）
    const char* keyId;
    const char* idDefault;

    // label の保存キーとデフォルト値（English は固定値、Feature は空）
    const char* keyLabel;
    const char* labelDefault;

    // UI の objectName（Feature で空の場合もある）
    const char* objectName;
};



void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramDefinition(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramDefinition(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramDefinition(p, ini);
    for (const auto &p : Constants::FeatureSettings)  loadProgramDefinition(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();
 
     // ===== 初期値設定（未設定の場合のみ） =====
    initDefaultSaveFolder();

    // ===== 妥当性チェック（存在しないフォルダなら空にする） =====
    validateSaveFolder();
       
    // ===== 初回起動時の OS 別初期化 =====
    initDefaultFfmpegFolder();

    // 妥当性確認（壊れたパスなら空にする）
    if (!isValidFfmpegFolder(ffmpegFolder)) {
        ffmpegFolder.clear();
    }

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}




#include <QTimer>

int main(int argc, char *argv[])
{
#if defined(QT_NO_DEBUG)
#ifdef QT4_QT5_WIN
    const char* null = "nul";
#else
    const char* null = "/dev/null";
#endif
    freopen(null, "a", stdout);
    freopen(null, "a", stderr);
#endif

    QApplication a(argc, argv);
    MainWindow w;

    if (Utility::nogui()) {
        QTimer::singleShot(0, &w, SLOT(download()));
    } else {
        w.show();
    }

    return a.exec();
}




inline constexpr std::size_t OPT_PRESET_SIZE = OptionalCount;
inline constexpr std::size_t PRESET_SIZE = SpecCount;


file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:25,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:6:39: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
    6 |     inline constexpr char*  AppName = "語学講座ＣＳ２";
      |                                       ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:7:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
    7 |     inline constexpr char*  AppVersion = "2026/01/29";
      |                                          ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:10:43: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   10 |     inline constexpr char*  IniFileName = "CaptureStream2.ini";
      |                                           ^~~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:13:56: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   13 |     inline constexpr char*  SETTING_GROUP_MainWindow = "MainWindow";
      |                                                        ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:14:61: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   14 |    inline constexpr char*  SETTING_GROUP_CustomizeDialog = "CustomizeDialog";
      |                                                            ^~~~~~~~~~~~~~~~~

/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:15:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   15 |     inline constexpr char*  SETTING_GROUP_MessageWindow = "MessageWindow";
      |                                                           ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:16:60: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   16 |     inline constexpr char*  SETTING_GROUP_ScrambleDialog = "ScrambleDialog";
      |                                                            ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:17:60: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   17 |     inline constexpr char*  SETTING_GROUP_Settingsdialog = "Settingsdialog";
      |                                                            ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:20:50: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   20 |     inline constexpr char*  KEY_AudioExtension = "audio_extension";
      |                                                  ^~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:21:54: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   21 |     inline constexpr char*  DEFAULT_AudioExtension = "m4a";
      |                                                      ^~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:25:50: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   25 |     inline constexpr char*  KEY_SaveFolder     = "save_folder";
      |                                                  ^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:26:50: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   26 |     inline constexpr char*  KEY_FfmpegFolder   = "ffmpeg_folder";
      |                                                  ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:29:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   29 |     inline constexpr char*  KEY_basic0 = "basic0";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:30:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   30 |     inline constexpr char*  KEY_basic1 = "basic1";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:31:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   31 |     inline constexpr char*  KEY_basic2 = "basic2";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:32:45: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   32 |     inline constexpr char*  KEY_timetrial = "timetrial";
      |                                             ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:33:41: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   33 |     inline constexpr char*  KEY_enjoy = "enjoy";
      |                                         ^~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:34:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   34 |     inline constexpr char*  KEY_kaiwa =  "kaiwa";
      |                                          ^~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:35:44: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   35 |     inline constexpr char*  KEY_business = "business1";
      |                                            ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:36:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   36 |     inline constexpr char*  KEY_gendai = "gendai";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:39:51: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   39 |     inline constexpr char*  KEY_KOZA_SEPARATION = "koza_separation";
      |                                                   ^~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:40:45: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   40 |     inline constexpr char*  KEY_MULTI_GUI = "multi_gui";
      |                                             ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:41:46: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   41 |     inline constexpr char*  KEY_NAME_SPACE = "name_space";
      |                                              ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:42:45: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   42 |     inline constexpr char*  KEY_TAG_SPACE = "tag_space";
      |                                             ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:43:43: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   43 |     inline constexpr char*  KEY_NOGUI   = "nogui";              // CLI: -nogui
      |                                           ^~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:44:51: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   44 |     inline constexpr char*  KEY_LAST_WEEK       = "last_week";          // GUI: [前週]、CLI: -z
      |                                                   ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:45:51: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   45 |     inline constexpr char*  KEY_BOTH_WEEKS      = "both_weeks";         // CLI: -b
      |                                                   ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:46:48: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   46 |     inline constexpr char*  KEY_PROGRAM_LIST = "program_list";  // GUI: 番組一覧表示
      |                                                ^~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:49:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   49 |     inline constexpr char*  KEY_CUSTOMIZED_TITLE1       = "customized_title1";
      |                                                           ^~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:50:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   50 |     inline constexpr char*  KEY_CUSTOMIZED_TITLE2       = "customized_title2";
      |                                                           ^~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:51:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   51 |     inline constexpr char*  KEY_CUSTOMIZED_FILENAME1    = "customized_file_name1";
      |                                                           ^~~~~~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:52:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   52 |     inline constexpr char*  KEY_CUSTOMIZED_FILENAME2    = "customized_file_name2";
      |                                                           ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:62:51: error: the value of ‘Constants::OPT_PRESET_SIZE’ is not usable in a constant expression
   62 |     std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
      |                                                   ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:173:22: note: ‘Constants::OPT_PRESET_SIZE’ was not initialized with a constant expression
  173 |     extern const int OPT_PRESET_SIZE = OptionalCount;
      |                      ^~~~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:62:51: note: in template argument for type ‘long unsigned int’
   62 |     std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
      |                                                   ^
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:63:47: error: the value of ‘Constants::PRESET_SIZE’ is not usable in a constant expression
   63 |     std::array<QString, Constants::PRESET_SIZE> specials;
      |                                               ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:195:22: note: ‘Constants::PRESET_SIZE’ was not initialized with a constant expression
  195 |     extern const int PRESET_SIZE = SpecCount;
      |                      ^~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:63:47: note: in template argument for type ‘long unsigned int’
   63 |     std::array<QString, Constants::PRESET_SIZE> specials;
      |                                               ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:41,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:53:39: error: size of array ‘english’ is not an integral constant-expression
   53 |     RuntimeProgram english[Constants::EnglishCount];
      |                            ~~~~~~~~~~~^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:54:40: error: size of array ‘optional’ is not an integral constant-expression
   54 |     RuntimeProgram optional[Constants::OptionalCount];
      |                             ~~~~~~~~~~~^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:55:36: error: size of array ‘spec’ is not an integral constant-expression
   55 |     RuntimeProgram spec[Constants::SpecCount];
      |                         ~~~~~~~~~~~^~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:56:30: error: size of array ‘checkBox’ is not an integral constant-expression
   56 |     bool checkBox[Constants::FeatureCount];
      |                   ~~~~~~~~~~~^~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_scrambledialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:7:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../scrambledialog.h:53:54: error: the value of ‘Constants::OPT_PRESET_SIZE’ is not usable in a constant expression
   53 |     std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;
      |                                                      ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:173:22: note: ‘Constants::OPT_PRESET_SIZE’ was not initialized with a constant expression
  173 |     extern const int OPT_PRESET_SIZE = OptionalCount;
      |                      ^~~~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_scrambledialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:7:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../scrambledialog.h:53:54: note: in template argument for type ‘long unsigned int’
   53 |     std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;
      |                                                      ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_settingsdialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:8:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settingsdialog.h:53:50: error: the value of ‘Constants::PRESET_SIZE’ is not usable in a constant expression
   53 |     std::array<QLineEdit*, Constants::PRESET_SIZE> edits;
      |                                                  ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:195:22: note: ‘Constants::PRESET_SIZE’ was not initialized with a constant expression
  195 |     extern const int PRESET_SIZE = SpecCount;
      |                      ^~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_settingsdialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:8:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settingsdialog.h:53:50: note: in template argument for type ‘long unsigned int’
   53 |     std::array<QLineEdit*, Constants::PRESET_SIZE> edits;
      |                                                  ^
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:85: CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2




struct ProgramDefinition {
    enum class Kind {
        English,   // 固定番組
        Optional,  // 任意設定番組
        Spec,      // 特番
        Feature    // チェックボックス
    };

    Kind kind;

    // checked の保存キーとデフォルト値
    const char* keyChecked;
    bool    checkedDefault;

    // id の保存キーとデフォルト値（English/Feature は空）
    const char* keyId;
    const char* idDefault;
    bool hasId;

    // label の保存キーとデフォルト値（English は固定値、Feature は空）
    const char* keyLabel;
    const char* labelDefault;
    bool hasLabel;

    // UI の objectName（Feature で空の場合もある）
    const char* objectName;
};






エラーメッセージ
QVector<ProgramEntry> RuntimeConfig::allPrograms() const
を
QVector<RuntimeConfig::ProgramEntry> RuntimeConfig::allPrograms() const
に変更するとエラーは消える
Constants::ProgramEntryは全てリネーム済み



[ 83%] Building CXX object CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:118:9: error: ‘ProgramEntry’ was not declared in this scope
  118 | QVector<ProgramEntry> RuntimeConfig::allPrograms() const
      |         ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:118:21: error: template argument 1 is invalid
  118 | QVector<ProgramEntry> RuntimeConfig::allPrograms() const
      |                     ^
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:118:23: error: no declaration matches ‘int RuntimeConfig::allPrograms() const’
  118 | QVector<ProgramEntry> RuntimeConfig::allPrograms() const
      |                       ^~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:24:
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:96:27: note: candidate is: ‘QVector<RuntimeConfig::ProgramEntry> RuntimeConfig::allPrograms() const’
   96 |     QVector<ProgramEntry> allPrograms() const;
      |                           ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:41:7: note: ‘class RuntimeConfig’ defined here
   41 | class RuntimeConfig
      |       ^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:155:9: error: ‘ProgramEntry’ was not declared in this scope
  155 | QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
      |         ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:155:21: error: template argument 1 is invalid
  155 | QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
      |                     ^
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:155:23: error: no declaration matches ‘int RuntimeConfig::checkedPrograms() const’
  155 | QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
      |                       ^~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:24:
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:98:27: note: candidate is: ‘QVector<RuntimeConfig::ProgramEntry> RuntimeConfig::checkedPrograms() const’
   98 |     QVector<ProgramEntry> checkedPrograms() const;
      |                           ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:41:7: note: ‘class RuntimeConfig’ defined here
   41 | class RuntimeConfig
      |       ^~~~~~~~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:253: CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2




ProgramDefinition


struct ProgramEntry
{
    bool checked;        // 有効かどうか
    QString id;          // 実行に使う ID
    QString label;       // 表示用ラベル
    QString category;    // "english" / "optional" / "spec"
};

QVector<ProgramEntry> allPrograms() const;

QVector<ProgramEntry> checkedPrograms() const;

QVector<ProgramEntry> RuntimeConfig::allPrograms() const
{
    QVector<ProgramEntry> list;

    // English
    for (int i = 0; i < Constants::EnglishCount; i++) {
        ProgramEntry e;
        e.checked  = english[i].checked;
        e.id       = english[i].id;
        e.label    = english[i].label;
        e.category = "english";
        list.append(e);
    }

    // Optional
    for (int i = 0; i < Constants::OptionalCount; i++) {
        ProgramEntry e;
        e.checked  = optional[i].checked;
        e.id       = optional[i].id;
        e.label    = optional[i].label;
        e.category = "optional";
        list.append(e);
    }

    // Spec
    for (int i = 0; i < Constants::SpecCount; i++) {
        ProgramEntry e;
        e.checked  = spec[i].checked;
        e.id       = spec[i].id;
        e.label    = spec[i].label;
        e.category = "spec";
        list.append(e);
    }

    return list;
}

QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
{
    QVector<ProgramEntry> list;

    // English
    for (int i = 0; i < Constants::EnglishCount; i++) {
        if (english[i].checked) {
            ProgramEntry e;
            e.checked  = true;
            e.id       = english[i].id;
            e.label    = english[i].label;
            e.category = "english";
            list.append(e);
        }
    }

    // Optional
    for (int i = 0; i < Constants::OptionalCount; i++) {
        if (optional[i].checked) {
            ProgramEntry e;
            e.checked  = true;
            e.id       = optional[i].id;
            e.label    = optional[i].label;
            e.category = "optional";
            list.append(e);
        }
    }

    // Spec
    for (int i = 0; i < Constants::SpecCount; i++) {
        if (spec[i].checked) {
            ProgramEntry e;
            e.checked  = true;
            e.id       = spec[i].id;
            e.label    = spec[i].label;
            e.category = "spec";
            list.append(e);
        }
    }

    return list;
}

for (auto &p : config.checkedPrograms()) {
    runProgram(p.id);
}








#pragma once
#include <QString>
#include <QMap>
#include <vector>
#include <optional>

#include "settings.h"
#include "clioptions.h"
#include "constants.h"

class RuntimeConfig
{
public:
    RuntimeConfig();

    void applySettings(const Settings &s);
    void applyCommandLine(const CliOptions &cli);

    void setFlag(const QString &key, bool value);
    bool flag(const QString &key) const;

public:
    // ===== GUI: English / Optional / Spec =====
    ProgramEntry english[Constants::EnglishCount];
    ProgramEntry optional[Constants::OptionalCount];
    ProgramEntry spec[Constants::SpecCount];

    // ===== GUI: Feature チェックボックス =====
    bool checkBox[Constants::FeatureCount];

    // ===== GUI: その他設定 =====
    QString saveFolder;
    QString ffmpegFolder;
    QString audioExtension;

    // ===== GUI: CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    // ===== CLI: 録画設定 =====
    std::optional<QString> cliTitleTagFormat;   // -t
    std::optional<QString> cliFileNameFormat;   // -f
    std::optional<QString> cliOutputFolder;     // -o
    std::optional<QString> cliExtension;        // -e

    std::vector<QString> cliProgramIds;

    // ===== flags（GUI + CLI 統合）=====
    QMap<QString, bool> flags;
};


#include "runtimeconfig.h"
#include "constants.h"

RuntimeConfig::RuntimeConfig()
{
    // flags 初期化
    for (int i = 0; i < Constants::FlagCount; ++i) {
        const auto &f = Constants::FlagTable[i];
        flags[f.keyFlag] = f.flagDefault;
    }
}

void RuntimeConfig::applySettings(const Settings &s)
{
    // ===== English =====
    for (int i = 0; i < Constants::EnglishCount; i++) {
        const auto &p = Constants::EnglishPrograms[i];
        english[i].checked = s.checked[p.keyChecked];
        english[i].id      = p.idDefault;
        english[i].label   = p.labelDefault;
    }

    // ===== Optional =====
    for (int i = 0; i < Constants::OptionalCount; i++) {
        const auto &p = Constants::OptionalPrograms[i];
        optional[i].checked = s.checked[p.keyChecked];
        optional[i].id      = s.ids[p.keyId];
        optional[i].label   = s.labels[p.keyLabel];
    }

    // ===== Spec =====
    for (int i = 0; i < Constants::SpecCount; i++) {
        const auto &p = Constants::SpecPrograms[i];
        spec[i].checked = s.checked[p.keyChecked];
        spec[i].id      = s.ids[p.keyId];
        spec[i].label   = s.labels[p.keyLabel];
    }

    // ===== Feature（チェックボックス）=====
    for (int i = 0; i < Constants::FeatureCount; i++) {
        const auto &p = Constants::FeatureSettings[i];
        checkBox[i] = s.checked[p.keyChecked];
        setFlag(p.keyChecked, s.checked[p.keyChecked]);
    }

    // ===== その他設定 =====
    saveFolder     = s.saveFolder;
    ffmpegFolder   = s.ffmpegFolder;
    audioExtension = s.audioExtension;

    // ===== CustomizeDialog =====
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        titleFormat[i]    = s.titleFormat[i];
        fileNameFormat[i] = s.fileNameFormat[i];
    }
}

void RuntimeConfig::applyCommandLine(const CliOptions &cli)
{
    // ===== CLI: 録画設定 =====
    if (cli.titleTagFormat)
        cliTitleTagFormat = *cli.titleTagFormat;

    if (cli.fileNameFormat)
        cliFileNameFormat = *cli.fileNameFormat;

    if (cli.outputFolder)
        cliOutputFolder = *cli.outputFolder;

    if (cli.extension)
        cliExtension = *cli.extension;

    if (!cli.programIds.empty())
        cliProgramIds = cli.programIds;

    // ===== CLI: flags =====
    for (const auto &key : cli.enabledKeys)
        setFlag(key, true);
}

void RuntimeConfig::setFlag(const QString &key, bool value)
{
    flags[key] = value;
}

bool RuntimeConfig::flag(const QString &key) const
{
    return flags.value(key, false);
}









GUIも含めてsettingsの下記の部分がrunntimeConfigに反映されていない
    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();



 1. clioptions.h（CLI 専用構造体）

#pragma once
#include <QString>
#include <vector>
#include <optional>

struct CliOptions {
    bool nogui = false;

    std::vector<QString> programIds;

    std::optional<QString> titleTagFormat;   // -t
    std::optional<QString> fileNameFormat;   // -f
    std::optional<QString> outputFolder;     // -o
    std::optional<QString> extension;        // -e

    bool optionZ = false;  // -z
    bool optionB = false;  // -b
    bool optionS = false;  // -s

    // ★ CLI が有効化した keyOption を保持
    std::vector<QString> enabledKeys;
};


---

✅ 2. commandlineparser.h

#pragma once
#include "clioptions.h"

class CommandLineParser {
public:
    static CliOptions parse(int argc, char* argv[]);
};


---

✅ 3. commandlineparser.cpp（keyOption 対応版）

#include "commandlineparser.h"
#include "constants.h"
#include <QString>

CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    auto findOption = [&](const QString& arg) -> const Constants::CliOption* {
        for (int i = 0; i < Constants::OPTION_TABLE_COUNT; ++i) {
            if (arg == Constants::OPTION_TABLE[i].name)
                return &Constants::OPTION_TABLE[i];
        }
        return nullptr;
    };

    for (int i = 1; i < argc; ++i) {
        QString arg = argv[i];
        const Constants::CliOption* opt = findOption(arg);

        if (!opt) {
            // プログラムIDとして扱う
            opts.programIds.push_back(arg);
            continue;
        }

        // 値を取るオプション
        if (opt->requiresValue) {
            if (i + 1 >= argc)
                break;

            QString value = argv[++i];

            if (arg == "-t")      opts.titleTagFormat = value;
            else if (arg == "-f") opts.fileNameFormat = value;
            else if (arg == "-o") opts.outputFolder   = value;
            else if (arg == "-e") opts.extension      = value;

            // ★ keyOption を登録
            opts.enabledKeys.push_back(opt->keyOption);
        }
        else {
            // 値を取らないオプション
            if (arg == "-nogui") opts.nogui = true;
            else if (arg == "-z") opts.optionZ = true;
            else if (arg == "-b") opts.optionB = true;
            else if (arg == "-s") opts.optionS = true;

            // ★ keyOption を登録
            opts.enabledKeys.push_back(opt->keyOption);
        }
    }

    return opts;
}


---

✅ 4. runtimeconfig.h（applyCommandLine を CliOptions 版に変更）

void applyCommandLine(const CliOptions &cli);


---

✅ 5. runtimeconfig.cpp（flags 連動版）

#include "runtimeconfig.h"
#include "clioptions.h"

void RuntimeConfig::applyCommandLine(const CliOptions &cli)
{
    //
    // 1. 値を持つオプション
    //
    if (cli.outputFolder)
        saveFolder = *cli.outputFolder;

    if (cli.extension)
        audioExtension = *cli.extension;

    if (cli.titleTagFormat)
        titleTagFormat = *cli.titleTagFormat;

    if (cli.fileNameFormat)
        fileNameFormat = *cli.fileNameFormat;

    //
    // 2. フラグ系（-s, -z, -b, -nogui）
    //
    if (cli.optionS) optionS = true;
    if (cli.optionZ) optionZ = true;
    if (cli.optionB) optionB = true;
    if (cli.nogui)   nogui   = true;

    //
    // 3. programIds（CLI 専用）
    //
    if (!cli.programIds.empty())
        programIds = cli.programIds;

    //
    // 4. flags に反映（GUI と CLI の統合ポイント）
    //
    for (const auto &key : cli.enabledKeys)
        setFlag(key, true);
}


---



    // CLIコマンドラインオプション
struct CliOption {
    const char* name;
    bool requiresValue;
    QString keyOption;	// GUI、Flagの キーと一致
    QString description;
};

inline const CliOption OPTION_TABLE[] = {
    { "-nogui", false,	KEY_NOGUI,		"GUI を起動せずに実行します" },
    { "-t",     true,	KEY_CUSTOMIZED_TITLE1,	"タイトルタグ形式を指定します" },
    { "-f",     true,	KEY_CUSTOMIZED_FILENAME1, "ファイル名形式を指定します" },
    { "-o",     true,	KEY_SaveFolder,		"保存フォルダのフルパスを指定します" },
    { "-e",     true,	KEY_AudioExtension,	"拡張子を指定します" },
    { "-z",     false,	KEY_LAST_WEEK,		"前週の動作を行います" },
    { "-b",     false,	KEY_BOTH_WEEKS,		"前週と当週の両方を実行します" },
    { "-s",     false,	KEY_KOZA_SEPARATION,	"応用編分離を有効にします" },
};

constexpr int OPTION_TABLE_COUNT = std::size(OPTION_TABLE);



void RuntimeConfig::applyRecordingConfig(const RecordingConfig &rc)
{
    setFlag(Constants::KEY_NOGUI, rc.nogui);
    setFlag(Constants::KEY_Z, rc.optionZ);
    setFlag(Constants::KEY_B, rc.optionB);
    setFlag(Constants::KEY_S, rc.optionS);
}


[ 11%] Building CXX object CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp: In member function ‘void RuntimeConfig::applyCommandLine(const QMap<QString, QString>&)’:
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:124:35: error: ‘rc’ was not declared in this scope
  124 |     setFlag(Constants::KEY_NOGUI, rc.nogui);
      |                                   ^~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:253: CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2


void RuntimeConfig::applyRecordingConfig(const RecordingConfig &rc)
{
    setFlag("nogui", rc.nogui);
    setFlag("z", rc.optionZ);
    setFlag("b", rc.optionB);
    setFlag("s", rc.optionS);

    // 必要なら他の CLI オプションもここで統合
}




void RuntimeConfig::setFlag(const QString &key, bool value)
{
    flags[key] = value;
}

bool RuntimeConfig::flag(const QString &key) const
{
    return flags.value(key, false);
}


private:
    QMap<QString, bool> flags;


/* ============================================================
 * Flag（チェックボックス、CLIオプションなど）
 * ------------------------------------------------------------
 * ini ファイルに保存されない RuntimeConfig で使用する Flag。
 * RuntimeConfig 生成時に default で初期化され、
 * Settings / GUI / CLI によって上書きされる。
 * Feature と重複する場合は後からの値が優先される。
 * ========================================================== */   

struct FlagEntry {
    QString keyFlag;      // 例: "nogui"
    bool flagDefault;     // 初期値
};

inline const FlagEntry FlagTable[] = {
    { "nogui",        false }, // CLI: --nogui
    { "last_week",    false }, // GUI: [前週]
    { "both_weeks",   false }, // GUI: [前週+今週]
    { "program_list", false }, // GUI: 番組一覧表示
    { "featureX",     true  }  // Settings Feature
};

// ===== フラグの数 =====
constexpr int FlagCount = std::size(FlagTable);


namespace Constants {

struct FlagEntry {
    QString key;      // "previewEnabled" など
    bool defaultValue;
};

static const FlagEntry FlagTable[] = {
    { "previewEnabled", false },
    { "useNewMode",     false },
    { "featureX",       true  }, // ini に保存される Feature でもよい
    // ...
};


void RuntimeConfig::applySettings(const Settings &s)
{
    // Feature 系（ini に保存されるもの）
    for (int i = 0; i < Constants::FeatureCount; i++) {
        const auto &p = Constants::FeatureSettings[i];
        bool v = s.checked[p.keyChecked];
        checkBox[i] = v;
        setFlag(p.keyChecked, v);   // flags にも反映
    }

    // その他の Settings も必要に応じて flags にマージしてよい
}



static const int FlagCount = sizeof(FlagTable) / sizeof(FlagEntry);

} // namespace Constants


RuntimeConfig::RuntimeConfig()
{
    // すべてのフラグを定義済みの初期値で埋める
    for (int i = 0; i < Constants::FlagCount; ++i) {
        const auto &f = Constants::FlagTable[i];
        flags[f.key] = f.defaultValue;
    }
}




void MainWindow::customizeSaveFolder()
{
    auto &s = Settings::instance();
    QString base = s.saveFolder;

#if defined(Q_OS_WIN)
    QString folderPath;
    if (isWineEnvironment()) {
        folderPath = getPortableFolderDialog(
            this,
            tr("書き込み可能な保存フォルダを指定してください"),
            base
        );
    } else {
        folderPath = QFileDialog::getExistingDirectory(
            this,
            tr("書き込み可能な保存フォルダを指定してください"),
            base,
            QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
        );
    }
    QString dir = QFileInfo(folderPath).absoluteFilePath();
#else
    QString dir = QFileDialog::getExistingDirectory(
        this,
        tr("書き込み可能な保存フォルダを指定してください"),
        base,
        QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
    );
#endif

    if (!dir.isEmpty()) {
        s.saveFolder = dir + QDir::separator();
    }
}

void MainWindow::customizeFolderOpen()
{
    auto &s = Settings::instance();
    QString folder = s.saveFolder;

    bool success = false;

#if defined(Q_OS_WIN)
    if (isWineEnvironment()) {
        QString dir = convertWinePathToUnix(folder);
        openUrlWithFallbackDialog(QUrl::fromLocalFile(dir), this);
        success = true;
    } else {
        success = QDesktopServices::openUrl(QUrl("file:///" + folder, QUrl::TolerantMode));
    }
#elif defined(Q_OS_MAC)
    success = QDesktopServices::openUrl(QUrl("file:///" + folder, QUrl::TolerantMode));
#elif defined(Q_OS_LINUX)
    QString dir = convertWinePathToUnixAuto(folder);
    QString cmd = QString("xdg-open \"%1\"").arg(dir);
    openUrlWithFallbackDialog(QUrl::fromLocalFile(dir), this);
    success = QProcess::startDetached("/bin/sh", QStringList() << "-c" << cmd);
    if (!success) {
        success = QDesktopServices::openUrl(folder);
    }
#else
    success = QDesktopServices::openUrl(QUrl("file:///" + folder, QUrl::TolerantMode));
    if (!success) {
        success = QDesktopServices::openUrl(folder);
    }
#endif

    if (!success) {
        success = QDesktopServices::openUrl(folder);
    }

    if (!success) {
        QString fallbackMessage =
            tr("フォルダを開くことができませんでした。\nパス: %1").arg(folder);
        QMessageBox::warning(nullptr, tr("エラー"), fallbackMessage);
    }
}

void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    if (s.saveFolder.isEmpty()) {
        customizeSaveFolder();
    }

    // 他の復元処理…
}


private:
    void initDefaultSaveFolder();          // OS別初期値設定
    void validateSaveFolder();             // 妥当性チェック

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    saveFolder = ini.value(Constants::KEY_SaveFolder).toString();

    ini.endGroup();

    // ===== 初期値設定（未設定の場合のみ） =====
    initDefaultSaveFolder();

    // ===== 妥当性チェック（存在しないフォルダなら空にする） =====
    validateSaveFolder();
}

void Settings::initDefaultSaveFolder()
{
    if (!saveFolder.isEmpty())
        return;  // すでに設定済みなら何もしない

#ifdef Q_OS_WIN
    saveFolder = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
#elif defined(Q_OS_MAC)
    saveFolder = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
#elif defined(Q_OS_LINUX)
    saveFolder = QDir::homePath();
#else
    saveFolder = QDir::homePath();
#endif

    // 最後は必ず末尾にセパレータを付ける
    if (!saveFolder.endsWith(QDir::separator()))
        saveFolder += QDir::separator();
}

void Settings::validateSaveFolder()
{
    if (saveFolder.isEmpty())
        return;

    QDir dir(saveFolder);

    // フォルダが存在しない場合は空にする
    if (!dir.exists()) {
        saveFolder.clear();
        return;
    }

    // 書き込み可能かどうかの最低限チェック
    QFileInfo testFile(dir.filePath(".__cs2_test__"));
    QFile f(testFile.absoluteFilePath());

    if (f.open(QIODevice::WriteOnly)) {
        f.close();
        f.remove();  // テストファイル削除
    } else {
        // 書き込み不可 → 空にする
        saveFolder.clear();
    }
}








public:
    QString detectFfmpegFolder();   // MainWindow から呼べる

QString Settings::detectFfmpegFolder()
{
    return autoDetectFfmpeg();   // private 関数を内部で呼ぶ
}

QString dir = Settings::instance().detectFfmpegFolder();



QString ffmpegFolder;

private:
    void initDefaultFfmpegFolder();
    QString autoDetectFfmpeg();   // OS別探索



settings cpp

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    ini.endGroup();

    // ===== 初回起動時の OS 別初期化 =====
    initDefaultFfmpegFolder();
}

void Settings::initDefaultFfmpegFolder()
{
    if (!ffmpegFolder.isEmpty())
        return;  // すでに設定済み

    // OS別に自動探索
    QString detected = autoDetectFfmpeg();
    if (!detected.isEmpty()) {
        ffmpegFolder = detected;
        return;
    }

    // 見つからなければ空のまま（MainWindow がダイアログを出す）
    ffmpegFolder.clear();
}

QString Settings::autoDetectFfmpeg()
{
    QProcess process;
    QString ffmpegPath;

#ifdef Q_OS_WIN
    process.start("cmd.exe", QStringList() << "/c" << "where" << "ffmpeg");
#else
    process.start("which", QStringList() << "ffmpeg");
#endif
    process.waitForFinished();

    ffmpegPath = QString::fromUtf8(process.readAllStandardOutput())
                     .split("\n").first().trimmed();

    if (!QFileInfo::exists(ffmpegPath)) {
#ifdef Q_OS_MAC
        QString arch = QSysInfo::buildCpuArchitecture();
        if (arch == "x86_64") {
            ffmpegPath = "/usr/local/bin/ffmpeg";
        } else if (arch == "arm64") {
            ffmpegPath = "/opt/homebrew/bin/ffmpeg";
            if (!QFile::exists(ffmpegPath))
                ffmpegPath = "/usr/local/bin/ffmpeg";
        }
#elif defined(Q_OS_LINUX)
        ffmpegPath = "/usr/bin/ffmpeg";
#elif defined(Q_OS_WIN)
        ffmpegPath = "C:\\Program Files\\ffmpeg\\bin\\ffmpeg.exe";
        if (!QFile::exists(ffmpegPath))
            ffmpegPath = "C:\\ffmpeg\\bin\\ffmpeg.exe";
#endif
    }

    if (QFile::exists(ffmpegPath))
        return QFileInfo(ffmpegPath).absolutePath();

    return QString();
}

mainwindowcっp
void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // ffmpeg が未設定なら設定ダイアログを開く
    if (s.ffmpegFolder.isEmpty()) {
        ffmpegFolderDialog();
    }

    // その他の復元処理…
}


void MainWindow::ffmpegFolderDialog()
{
    auto &s = Settings::instance();

    QMessageBox msgBox(this);
    QString message = QString::fromUtf8("ffmpegがあるフォルダを設定しますか？\n現在設定：\n") 
                      + s.ffmpegFolder;
    msgBox.setIcon(QMessageBox::Question);
    msgBox.setWindowTitle(tr("ffmpegがあるフォルダ設定"));
    msgBox.setText(message);

    QPushButton* setButton = msgBox.addButton(tr("設定する"), QMessageBox::ActionRole);
    QPushButton* searchButton = msgBox.addButton(tr("検索"), QMessageBox::ActionRole);
    QPushButton* bundledButton = msgBox.addButton(tr("同梱"), QMessageBox::ActionRole);
    QPushButton* resetButton = msgBox.addButton(tr("初期値に戻す"), QMessageBox::ActionRole);
    msgBox.setStandardButtons(QMessageBox::Cancel);

    if (msgBox.exec() == QMessageBox::Cancel)
        return;

    QPushButton* clicked = qobject_cast<QPushButton*>(msgBox.clickedButton());

    if (clicked == setButton) {

        QString dir = QFileDialog::getExistingDirectory(
            this, tr("ffmpegがあるフォルダを指定してください"),
            s.ffmpegFolder,
            QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

        if (!dir.isEmpty())
            s.ffmpegFolder = dir + QDir::separator();

    } else if (clicked == resetButton) {

        s.ffmpegFolder = Utility::applicationBundlePath();

    } else if (clicked == searchButton) {

        QString dir = Settings::instance().autoDetectFfmpeg();
        if (!dir.isEmpty()) {
            QString msg = QString::fromUtf8("ffmpegがある下記フォルダを見つけました。\n設定しますか？\n\n") + dir;
            if (QMessageBox::Yes == QMessageBox::question(this, tr("ffmpegフォルダ設定"), msg))
                s.ffmpegFolder = dir + QDir::separator();
        }

    } else if (clicked == bundledButton) {

        QString dir = Utility::applicationBundlePath();
        QString msg = QString::fromUtf8("同梱のffmpegを使用します。\n設定しますか？\n\n") + dir;
        if (QMessageBox::Yes == QMessageBox::question(this, tr("同梱ffmpeg設定"), msg))
            s.ffmpegFolder = dir + QDir::separator();
    }
}

private:
    bool isValidFfmpegFolder(const QString& folder) const;
    bool canExecuteFfmpeg(const QString& ffmpegPath) const;


bool Settings::isValidFfmpegFolder(const QString& folder) const
{
    if (folder.isEmpty())
        return false;

    QDir dir(folder);
    if (!dir.exists())
        return false;

#ifdef Q_OS_WIN
    QString exe = dir.filePath("ffmpeg.exe");
#else
    QString exe = dir.filePath("ffmpeg");
#endif

    if (!QFileInfo::exists(exe))
        return false;

    return canExecuteFfmpeg(exe);
}

bool Settings::canExecuteFfmpeg(const QString& ffmpegPath) const
{
    QProcess p;
    p.start(ffmpegPath, {"-version"});
    if (!p.waitForFinished(1500))  // タイムアウト短めでOK
        return false;

    return (p.exitStatus() == QProcess::NormalExit);
}


void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    ffmpegFolder = ini.value(Constants::KEY_FfmpegFolder).toString();

    ini.endGroup();

    // OS別初期値設定（未設定の場合のみ）
    initDefaultFfmpegFolder();

    // 妥当性確認（壊れたパスなら空にする）
    if (!isValidFfmpegFolder(ffmpegFolder)) {
        ffmpegFolder.clear();
    }
}





// audio_extension
if (auto combo = findChild<QComboBox*>("comboBox_extension")) {
    int index = combo->findText(s.audioExtension);
    if (index >= 0)
        combo->setCurrentIndex(index);
}

// saveFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_saveFolder"))
    edit->setText(s.saveFolder);

// ffmpegFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_ffmpegFolder"))
    edit->setText(s.ffmpegFolder);

// audio_extension
if (auto combo = findChild<QComboBox*>("comboBox_extension"))
    s.audioExtension = combo->currentText();

// saveFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_saveFolder"))
    s.saveFolder = edit->text();

// ffmpegFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_ffmpegFolder"))
    s.ffmpegFolder = edit->text();




void MainWindow::updateButtonUI(QToolButton* btn, bool checked, const QString& label)
{
    btn->blockSignals(true);
    btn->setChecked(checked);
    btn->blockSignals(false);

    if (label.isEmpty())
        return;

    static const QString mark = QString::fromUtf8("✓ ");

    btn->setText(checked ? mark + label : label);
}

void MainWindow::saveGui()
{
    auto &s = Settings::instance();

    // geometry 保存
    s.saveMainWindow(saveGeometry());

    // English / Optional / Spec / Feature をすべて保存
    saveProgramButtons(Constants::EnglishPrograms, s);
    saveProgramButtons(Constants::OptionalPrograms, s);
    saveProgramButtons(Constants::SpecPrograms, s);
    saveProgramButtons(Constants::FeatureSettings, s);

    // 最後に settings.ini へ保存
    s.save();
}

template <typename Container>
void MainWindow::saveProgramButtons(const Container &programs, Settings &s)
{
    for (const auto &p : programs) {
        if (p.objectName.isEmpty())
            continue;

        // QAbstractButton で統一（QToolButton も QCheckBox も継承）
        if (auto btn = findChild<QAbstractButton*>(p.objectName)) {
            s.checked[p.keyChecked] = btn->isChecked();
        }
    }
}



void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry 復元
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // ===== English =====
    updateProgramButtons(Constants::EnglishPrograms, s);
     // ===== Optional =====   
    updateProgramButtons(Constants::OptionalPrograms, s);
    // ===== Spec =====
    updateProgramButtons(Constants::SpecPrograms, s);
    // ===== Feature（チェックボックス）=====
    updateProgramButtons(Constants::FeatureSettings, s);
}

template <typename Container>
void MainWindow::updateProgramButtons(const Container &programs, const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString label;
            if (p.keyLabel.isEmpty()) {
                // English
                label = p.labelDefault;
            } else {
                // Optional / Spec
                label = s.labels[p.keyLabel];
            }

            updateButtonUI(btn, s.checked[p.keyChecked], label);
        }
    }
}

void MainWindow::updateButtonUI(QToolButton* btn, bool checked, const QString& baseLabel)
{
    const QString check = QString::fromUtf8("✓ ");

    btn->blockSignals(true);
    btn->setChecked(checked);
    btn->blockSignals(false);

    if (baseLabel.isEmpty()) return;
    QString text = baseLabel;
    if (checked) {		
        text.prepend(check);	            // 状態に応じて「✓」付与
    }
    btn->setText(text);
}






settings.h

#pragma once
#include <QString>
#include <QSettings>
#include <QMap>
#include <QVector>
#include <QByteArray>
#include "constants.h"

class Settings
{
public:
    static Settings& instance();

    void load();
    void save();

    // ===== MainWindow / MessageWindow =====
    void loadMainWindow();
    void saveMainWindow(const QByteArray &geometry);

    void loadMessageWindow();
    void saveMessageWindow(const QByteArray &geometry);

    // ===== 基本設定 =====
    QString audioExtension;
    QString ffmpegFolder;
    QString saveFolder;

    // ===== ProgramEntry の値（checked / id / label）=====
    // keyChecked → checked
    QMap<QString, bool> checked;

    // keyId → id
    QMap<QString, QString> ids;

    // keyLabel → label
    QMap<QString, QString> labels;

    // ===== optional / spec のプリセット =====
    std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
    std::array<QString, Constants::PRESET_SIZE> specials;

    // ===== geometry =====
    QByteArray mainWindowGeometry;
    QByteArray messageWindowGeometry;

    // ===== CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    static QString getTitleFormat(int index);
    static QString getFileNameFormat(int index);

    static void setTitleFormatValue(int index, const QString &value);
    static void setFileNameFormatValue(int index, const QString &value);

    // ===== CheckBox features =====
    static bool tagSpaceFlag();
    static bool nameSpaceFlag();
    static bool multiGuiFlag();
    static bool kozaSeparationFlag();

    static void setTagSpaceFlag(bool flag);
    static void setNameSpaceFlag(bool flag);
    static void setMultiGuiFlag(bool flag);
    static void setKozaSeparationFlag(bool flag);

private:
    Settings();
    Settings(const Settings&) = delete;
    Settings& operator=(const Settings&) = delete;

    // 内部ヘルパー
    void loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
    void saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
};



settings.cpp

#include "settings.h"
#include <QSettings>

Settings::Settings()
{
}

Settings& Settings::instance()
{
    static Settings inst;
    return inst;
}

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramEntry(p, ini);
    for (const auto &p : Constants::FeatureSettings)     loadProgramEntry(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}

void Settings::save()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて保存
    for (const auto &p : Constants::EnglishPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     saveProgramEntry(p, ini);
    for (const auto &p : Constants::FeatureSettings)     saveProgramEntry(p, ini);

    ini.setValue(Constants::KEY_AudioExtension, audioExtension);

    if (saveFolder.isNull()) ini.remove(Constants::KEY_SaveFolder);
    else ini.setValue(Constants::KEY_SaveFolder, saveFolder);

    if (ffmpegFolder.isNull()) ini.remove(Constants::KEY_FfmpegFolder);
    else ini.setValue(Constants::KEY_FfmpegFolder, ffmpegFolder);

    ini.setValue("geometry", mainWindowGeometry);

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", messageWindowGeometry);
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        ini.setValue(QString("optional%1").arg(i + 1), optionals[i]);
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        ini.setValue(QString("special%1").arg(i + 1), specials[i]);
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        ini.setValue(t.key, titleFormat[i]);

        const auto &f = Constants::FILENAME_ITEMS[i];
        ini.setValue(f.key, fileNameFormat[i]);
    }
    ini.endGroup();
}

/* ============================================================
 * ProgramEntry 読み込み
 * ============================================================ */
void Settings::loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    // checked
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id
    if (!p.keyId.isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // label
    if (!p.keyLabel.isEmpty())
        labels[p.keyLabel] = ini.value(p.keyLabel, p.labelDefault).toString();
}

/* ============================================================
 * ProgramEntry 保存
 * ============================================================ */
void Settings::saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    ini.setValue(p.keyChecked, checked[p.keyChecked]);

    if (!p.keyId.isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!p.keyLabel.isEmpty())
        ini.setValue(p.keyLabel, labels[p.keyLabel]);
}

/* ============================================================
 *  CustomizeDialog API
 * ============================================================ */
QString Settings::getTitleFormat(int index)
{
    return instance().titleFormat[index];
}

QString Settings::getFileNameFormat(int index)
{
    return instance().fileNameFormat[index];
}

void Settings::setTitleFormatValue(int index, const QString &value)
{
    instance().titleFormat[index] = value;
}

void Settings::setFileNameFormatValue(int index, const QString &value)
{
    instance().fileNameFormat[index] = value;
}

/* ============================================================
 *  CheckBox features
 * ============================================================ */
bool Settings::tagSpaceFlag()
{
    return instance().checked[Constants::KEY_TAG_SPACE];
}

bool Settings::nameSpaceFlag()
{
    return instance().checked[Constants::KEY_NAME_SPACE];
}

bool Settings::multiGuiFlag()
{
    return instance().checked[Constants::KEY_MULTI_GUI];
}

bool Settings::kozaSeparationFlag()
{
    return instance().checked[Constants::KEY_KOZA_SEPARATION];
}

void Settings::setTagSpaceFlag(bool flag)
{
    instance().checked[Constants::KEY_TAG_SPACE] = flag;
}

void Settings::setNameSpaceFlag(bool flag)
{
    instance().checked[Constants::KEY_NAME_SPACE] = flag;
}

void Settings::setMultiGuiFlag(bool flag)
{
    instance().checked[Constants::KEY_MULTI_GUI] = flag;
}

void Settings::setKozaSeparationFlag(bool flag)
{
    instance().checked[Constants::KEY_KOZA_SEPARATION] = flag;
}

void Settings::loadMainWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    mainWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMainWindow(const QByteArray &geometry)
{
    mainWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}

void Settings::loadMessageWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMessageWindow(const QByteArray &geometry)
{
    messageWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}











private:
    const Constants::ProgramEntry* findEntryByObjectName(const QString& obj) const;


void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button)
        return;

    const QString obj = button->objectName();

    // ProgramEntry を objectName から直接検索
    const Constants::ProgramEntry* p = findEntryByObjectName(obj);
    if (!p)
        return;

    // Settings を更新
    Settings& s = Settings::instance();
    s.enabled[p->keyEnabled] = checked;

    // タイトルは Settings から取得（ここが最重要）
    QString baseTitle;
    if (!p->keyTitle.isEmpty()) {
        // ユーザーが変更したタイトル
        baseTitle = s.titles[p->keyTitle];
    } else {
        // English など固定タイトル
        baseTitle = p->titleDefault;
    }

    // UI 更新（✓ の付け外しだけ担当）
    updateButtonUI(button, checked, baseTitle);
}


const Constants::ProgramEntry* MainWindow::findEntryByObjectName(const QString& obj) const
{
    auto search = [&](const auto& list) -> const Constants::ProgramEntry* {
        for (const auto& p : list) {
            if (p.objectName == obj)
                return &p;
        }
        return nullptr;
    };

    if (auto* p = search(Constants::EnglishPrograms))  return p;
    if (auto* p = search(Constants::OptionalPrograms)) return p;
    if (auto* p = search(Constants::SpecPrograms))     return p;

    return nullptr;
}



void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ProgramEntry を直接探す
    const Constants::ProgramEntry* p = nullptr;

    auto findEntry = [&](const auto& list) {
        for (const auto& e : list) {
            if (e.objectName == obj) {
                p = &e;
                return;
            }
        }
    };

    findEntry(Constants::EnglishPrograms);
    findEntry(Constants::OptionalPrograms);
    findEntry(Constants::SpecPrograms);

    if (!p) return;  // 見つからない → 何もしない

    // Settings を更新
    Settings::instance().enabled[p->keyEnabled] = checked;

    // UI 更新
    updateButtonUI(button, checked, p->titleDefault);
}



template <typename Container>
void MainWindow::updateProgramButtons(const Container &programs, const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title;
            if (p.keyTitle.isEmpty()) {
                // English
                title = p.titleDefault;
            } else {
                // Optional / Spec
                title = s.titles[p.keyTitle];
            }

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}

template <typename Container>
void updateProgramButtons(const Container &programs, const Settings &s);
auto &s = Settings::instance();
updateProgramButtons(Constants::SpecPrograms, s);


void MainWindow::updateProgramButtons(
    const QVector<ProgramEntry> &programs,
    const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title;

            if (p.keyTitle.isEmpty()) {
                // English
                title = p.titleDefault;
            } else {
                // Optional / Spec
                title = s.titles[p.keyTitle];
            }

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}

updateProgramButtons(Constants::EnglishPrograms, s, true);
updateProgramButtons(Constants::OptionalPrograms, s, false);
updateProgramButtons(Constants::SpecPrograms, s, false);

void MainWindow::updateProgramButtons(
    const QVector<ProgramEntry> &programs,
    const Settings &s,
    bool useDefaultTitle)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title = useDefaultTitle
                ? p.titleDefault
                : s.titles[p.keyTitle];

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}







#include <QToolButton>




void MainWindow::updateButtonUI(QToolButton* btn, bool enabled, const QString& baseTitle)
{
    const QString check = QString::fromUtf8("✓ ");

    btn->blockSignals(true);
    btn->setChecked(enabled);
    btn->blockSignals(false);

    QString text = baseTitle;
    if (enabled) {
        text.prepend(check);
    }
    btn->setText(text);
}

void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // English
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], p.titleDefault);
        }
    }

    // Optional
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Spec
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Flag
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
        }
    }
}

void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ① settings.enabled を更新
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        Settings::instance().enabled[key] = checked;
    }

    // ② UI 更新（✓ の付け外し）
    QString baseTitle = button->text();
    const QString check = QString::fromUtf8("✓ ");

    // ✓ を除去して baseTitle を作る
    if (baseTitle.startsWith(check)) {
        baseTitle.remove(0, check.size());
    }

    updateButtonUI(button, checked, baseTitle);
}







/* ============================================================
 *  CustomizeDialog API
 * ============================================================ */
QString Settings::getTitleFormat(int index)
{
    return instance().titleFormat[index];
}

QString Settings::getFileNameFormat(int index)
{
    return instance().fileNameFormat[index];
}

void Settings::setTitleFormatValue(int index, const QString &value)
{
    instance().titleFormat[index] = value;
}

void Settings::setFileNameFormatValue(int index, const QString &value)
{
    instance().fileNameFormat[index] = value;
}

/* ============================================================
 *  CheckBox flags
 * ============================================================ */
bool Settings::tagSpaceFlag()
{
    return instance().enabled[Constants::KEY_TAG_SPACE];
}

bool Settings::nameSpaceFlag()
{
    return instance().enabled[Constants::KEY_NAME_SPACE];
}

bool Settings::multiGuiFlag()
{
    return instance().enabled[Constants::KEY_MULTI_GUI];
}

bool Settings::kozaSeparationFlag()
{
    return instance().enabled[Constants::KEY_KOZA_SEPARATION];
}

void Settings::setTagSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_TAG_SPACE] = flag;
}

void Settings::setNameSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_NAME_SPACE] = flag;
}

void Settings::setMultiGuiFlag(bool flag)
{
    instance().enabled[Constants::KEY_MULTI_GUI] = flag;
}

void Settings::setKozaSeparationFlag(bool flag)
{
    instance().enabled[Constants::KEY_KOZA_SEPARATION] = flag;
}

void Settings::loadMainWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    mainWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMainWindow(const QByteArray &geometry)
{
    mainWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}

void Settings::loadMessageWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMessageWindow(const QByteArray &geometry)
{
    messageWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}







[100%] Linking CXX executable CaptureStream2
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::formats(QString, QString&, QString&)':
customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x5f): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x8f): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::loadSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x43): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x56): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x9b): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xae): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xea): undefined reference to `Settings::tagSpaceFlag()'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x10c): undefined reference to `Settings::nameSpaceFlag()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::saveSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x5b): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x97): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xc0): undefined reference to `Settings::setTagSpaceFlag(bool)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xf2): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x12e): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x157): undefined reference to `Settings::setNameSpaceFlag(bool)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::saveGui()':
mainwindow.cpp:(.text._ZN10MainWindow7saveGuiEv+0x5a): undefined reference to `Settings::saveMainWindow(QByteArray const&)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeScramble()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeScrambleEv+0x33): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeSettings()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeSettingsEv+0x30): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::download()':
mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x2a): undefined reference to `MainWindow::collectEnglishSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x36): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x42): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x4e): undefined reference to `MainWindow::collectCheckBoxSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/messagewindow.cpp.o: in function `MessageWindow::~MessageWindow()':
messagewindow.cpp:(.text._ZN13MessageWindowD2Ev+0x8b): undefined reference to `Settings::saveMessageWindow(QByteArray const&)'
collect2: error: ld returned 1 exit status
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:457: CaptureStream2] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2





#pragma once
#include <QString>
#include <QStringList>
#include <QMap>
#include "constants.h"
#include "settings.h"

// ===== 実行時に使う番組データ =====
struct RuntimeProgram {
    QString id;      // 実際に使用する番組ID
    QString title;   // 実際に使用するタイトル
    bool enabled;    // 実行対象かどうか
};

class RuntimeConfig
{
public:
    RuntimeConfig();

    // Settings → RuntimeConfig へコピー
    void applySettings(const Settings &s);

    // CLI オプションで上書き
    void applyCommandLine(const QMap<QString, QString> &opts);

    // ===== 実行時の最終値 =====
    RuntimeProgram english[Constants::EnglishCount];
    RuntimeProgram optional[Constants::OptionalCount];
    RuntimeProgram spec[Constants::SpecCount];
    bool checkBox[Constants::FlagCount];

    // ===== その他設定 =====
    QString saveFolder;
    QString audioExtension;

    // 最新番組一覧（ProgramEntry に変更）
    QMap<QString, Constants::ProgramEntry> latestProgramMap;

    // name_map / id_map / thumbnail_map
    QMap<QString, QString> id_map;
    QMap<QString, QString> name_map;
    QMap<QString, QString> thumbnail_map;
};


#include "runtimeconfig.h"
#include "constants.h"

RuntimeConfig::RuntimeConfig()
{
}

void RuntimeConfig::applySettings(const Settings &s)
{
    // ===== English =====
    for (int i = 0; i < Constants::EnglishCount; i++) {
        const auto &p = Constants::EnglishPrograms[i];

        english[i].enabled = s.enabled[p.keyEnabled];
        english[i].id      = p.idDefault;       // English は固定
        english[i].title   = p.titleDefault;    // English は固定
    }

    // ===== Optional =====
    for (int i = 0; i < Constants::OptionalCount; i++) {
        const auto &p = Constants::OptionalPrograms[i];

        optional[i].enabled = s.enabled[p.keyEnabled];
        optional[i].id      = s.ids[p.keyId];
        optional[i].title   = s.titles[p.keyTitle];
    }

    // ===== Spec =====
    for (int i = 0; i < Constants::SpecCount; i++) {
        const auto &p = Constants::SpecPrograms[i];

        spec[i].enabled = s.enabled[p.keyEnabled];
        spec[i].id      = s.ids[p.keyId];
        spec[i].title   = s.titles[p.keyTitle];
    }

    // ===== Flag（チェックボックス）=====
    for (int i = 0; i < Constants::FlagCount; i++) {
        const auto &p = Constants::FlagSettings[i];
        checkBox[i] = s.enabled[p.keyEnabled];
    }

    // ===== その他設定 =====
    saveFolder     = s.saveFolder;
    audioExtension = s.audioExtension;
}

void RuntimeConfig::applyCommandLine(const QMap<QString, QString> &opts)
{
    // --save-folder
    if (opts.contains("save-folder"))
        saveFolder = opts["save-folder"];

    // --audio-ext
    if (opts.contains("audio-ext"))
        audioExtension = opts["audio-ext"];

    // --enable=xxx
    if (opts.contains("enable")) {
        QString key = opts["enable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = true;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = true;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = true;
    }

    // --disable=xxx
    if (opts.contains("disable")) {
        QString key = opts["disable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = false;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = false;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = false;
    }
}








#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class ScrambleDialog;
}

class ScrambleDialog : public QDialog {
    Q_OBJECT

public:
    explicit ScrambleDialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~ScrambleDialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::ScrambleDialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateOptional(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};


#include "scrambledialog.h"
#include "ui_scrambledialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

ScrambleDialog::ScrambleDialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::ScrambleDialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4,
              ui->edit5, ui->edit6, ui->edit7, ui->edit8 };

    // ===== OptionalPrograms の ID を Settings から復元 =====
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++) {
        const auto &p = Constants::OptionalPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== フラグ復元 =====
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

ScrambleDialog::~ScrambleDialog()
{
    delete ui;
}

void ScrambleDialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
}

QString ScrambleDialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = OPT_PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.optionals;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit *edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void ScrambleDialog::accept()
{
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++)
        updateOptional(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void ScrambleDialog::updateLabels()
{
    std::array<QLabel*, Constants::OPT_PRESET_SIZE> labels = {
        ui->label_2, ui->label_3, ui->label_4, ui->label_5,
        ui->label_6, ui->label_7, ui->label_8, ui->label_9
    };

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void ScrambleDialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {

            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void ScrambleDialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3] + "\n" +
        "５：" + titles[4] + "\n" +
        "６：" + titles[5] + "\n" +
        "７：" + titles[6] + "\n" +
        "８：" + titles[7];

    if (QMessageBox::question(this, tr("任意番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
            settings.optionals[i] = edits[i]->text();
    }
}

QString ScrambleDialog::updateOptional(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = OptionalPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}









#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class Settingsdialog;
}

class Settingsdialog : public QDialog {
    Q_OBJECT

public:
    explicit Settingsdialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~Settingsdialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::Settingsdialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateSpecial(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};



#include "settingsdialog.h"
#include "ui_settingsdialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

Settingsdialog::Settingsdialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::Settingsdialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4 };

    // ===== 特番（SpecPrograms）を Settings から復元 =====
    for (int i = 0; i < Constants::PRESET_SIZE; i++) {
        const auto &p = Constants::SpecPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== チェックボックスフラグ =====
    ui->checkBox->setChecked(settings.enabled[Constants::KEY_MULTI_GUI]);
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

Settingsdialog::~Settingsdialog()
{
    delete ui;
}

void Settingsdialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
    settings.enabled[Constants::KEY_MULTI_GUI] = ui->checkBox->isChecked();
}

QString Settingsdialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.specials;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit* edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void Settingsdialog::accept()
{
    for (int i = 0; i < Constants::PRESET_SIZE; i++)
        updateSpecial(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void Settingsdialog::updateLabels()
{
    std::array<QLabel*, Constants::PRESET_SIZE> labels =
        { ui->label_2, ui->label_3, ui->label_4, ui->label_5 };

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void Settingsdialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {
            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void Settingsdialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3];

    if (QMessageBox::question(this, tr("特別番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::PRESET_SIZE; ++i)
            settings.specials[i] = edits[i]->text();
    }
}

QString Settingsdialog::updateSpecial(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = SpecPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}






void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry 復元
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // ===== English =====
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);
            btn->setText(p.titleDefault);   // 固定タイトル
        }
    }

    // ===== Optional =====
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Spec =====
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Flag（チェックボックス）=====
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
            // ラベルは UI 側の固定値を使うので setText は不要
        }
    }
}

void MainWindow::saveGui()
{
    auto &s = Settings::instance();

    // geometry 保存
    s.saveMainWindow(saveGeometry());

    // enabled の書き戻し
    for (const auto &p : Constants::EnglishPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::OptionalPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::SpecPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::FlagSettings) {
        if (!p.objectName.isEmpty()) {
            if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = cb->isChecked();
            }
        }
    }

    // 最後に settings.ini へ保存
    s.save();
}





// Settings.h

#pragma once
#include <QString>
#include <QSettings>
#include <QMap>
#include <QVector>
#include <QByteArray>
#include "constants.h"

class Settings
{
public:
    static Settings& instance();

    void load();
    void save();

    // ===== MainWindow / MessageWindow =====
    void loadMainWindow();
    void saveMainWindow(const QByteArray &geometry);

    void loadMessageWindow();
    void saveMessageWindow(const QByteArray &geometry);

    // ===== 基本設定 =====
    QString audioExtension;
    QString ffmpegFolder;
    QString saveFolder;

    // ===== ProgramEntry の値（enabled / id / title）=====
    // keyEnabled → enabled
    QMap<QString, bool> enabled;

    // keyId → id
    QMap<QString, QString> ids;

    // keyTitle → title
    QMap<QString, QString> titles;

    // ===== optional / spec のプリセット =====
    std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
    std::array<QString, Constants::PRESET_SIZE> specials;

    // ===== geometry =====
    QByteArray mainWindowGeometry;
    QByteArray messageWindowGeometry;

    // ===== CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    static QString getTitleFormat(int index);
    static QString getFileNameFormat(int index);

    static void setTitleFormatValue(int index, const QString &value);
    static void setFileNameFormatValue(int index, const QString &value);

    // ===== CheckBox flags =====
    static bool tagSpaceFlag();
    static bool nameSpaceFlag();
    static bool multiGuiFlag();
    static bool kozaSeparationFlag();

    static void setTagSpaceFlag(bool flag);
    static void setNameSpaceFlag(bool flag);
    static void setMultiGuiFlag(bool flag);
    static void setKozaSeparationFlag(bool flag);

private:
    Settings();
    Settings(const Settings&) = delete;
    Settings& operator=(const Settings&) = delete;

    // 内部ヘルパー
    void loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
    void saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
};


//settings.cpp
#include "settings.h"
#include <QSettings>

Settings::Settings()
{
}

Settings& Settings::instance()
{
    static Settings inst;
    return inst;
}

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     loadProgramEntry(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}

void Settings::save()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて保存
    for (const auto &p : Constants::EnglishPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     saveProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     saveProgramEntry(p, ini);

    ini.setValue(Constants::KEY_AudioExtension, audioExtension);

    if (saveFolder.isNull()) ini.remove(Constants::KEY_SaveFolder);
    else ini.setValue(Constants::KEY_SaveFolder, saveFolder);

    if (ffmpegFolder.isNull()) ini.remove(Constants::KEY_FfmpegFolder);
    else ini.setValue(Constants::KEY_FfmpegFolder, ffmpegFolder);

    ini.setValue("geometry", mainWindowGeometry);

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", messageWindowGeometry);
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        ini.setValue(QString("optional%1").arg(i + 1), optionals[i]);
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        ini.setValue(QString("special%1").arg(i + 1), specials[i]);
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        ini.setValue(t.key, titleFormat[i]);

        const auto &f = Constants::FILENAME_ITEMS[i];
        ini.setValue(f.key, fileNameFormat[i]);
    }
    ini.endGroup();
}

/* ============================================================
 * ProgramEntry 読み込み
 * ============================================================ */
void Settings::loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    // enabled
    enabled[p.keyEnabled] =
        ini.value(p.keyEnabled, p.enabledDefault).toBool();

    // id
    if (!p.keyId.isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // title
    if (!p.keyTitle.isEmpty())
        titles[p.keyTitle] = ini.value(p.keyTitle, p.titleDefault).toString();
}

/* ============================================================
 * ProgramEntry 保存
 * ============================================================ */
void Settings::saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    ini.setValue(p.keyEnabled, enabled[p.keyEnabled]);

    if (!p.keyId.isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!p.keyTitle.isEmpty())
        ini.setValue(p.keyTitle, titles[p.keyTitle]);
}






class Settings {
public:
    static Settings& instance();

    // 既存のマップ
    QMap<QString, bool> englishEnabled;
    QMap<QString, bool> optionalEnabled;
    QMap<QString, bool> specEnabled;
    QMap<QString, bool> checkBoxEnabled;

    // ★ 追加：横断 enabled キャッシュ（INI に保存しない）
    QMap<QString, bool> enabled;

    void buildUnifiedEnabled();   // load() の後に呼ぶ
    void syncEnabledBack();       // save() の前に呼ぶ

    // ...
};


void Settings::buildUnifiedEnabled()
{
    enabled.clear();

    // English
    for (const auto& p : Constants::EnglishPrograms) {
        enabled[p.key] = englishEnabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        enabled[p.keyEnabled] = optionalEnabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        enabled[p.keyEnabled] = specEnabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        enabled[c.keyEnabled] = checkBoxEnabled[c.keyEnabled];
    }
}


void Settings::syncEnabledBack()
{
    // English
    for (const auto& p : Constants::EnglishPrograms) {
        englishEnabled[p.key] = enabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        optionalEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        specEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        checkBoxEnabled[c.keyEnabled] = enabled[c.keyEnabled];
    }
}



buildUnifiedEnabled();


syncEnabledBack();


QMap<QString, QString> objectToKey;


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    using namespace Constants;

    // English
    for (const auto& p : EnglishPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.key;
    }

    // Optional
    for (const auto& p : OptionalPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // Spec
    for (const auto& p : SpecPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // CheckBox
    for (const auto& c : CheckBoxSettings) {
        if (!c.objectName.isEmpty())
            objectToKey[c.objectName] = c.keyEnabled;
    }
}


void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ★ 横断 enabled に書き込むだけ
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        settings.enabled[key] = checked;
    }

    // UI のチェックマーク処理
    QString text = button->text();
    const QString check = QString::fromUtf8("✓ ");

    if (text.startsWith(check))
        text.remove(0, check.size());

    if (checked)
        text.prepend(check);

    button->setText(text);
}
