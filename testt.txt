void MainWindow::updateButtonUI(QToolButton* btn, bool enabled, const QString& baseTitle)
{
    const QString check = QString::fromUtf8("✓ ");

    btn->blockSignals(true);
    btn->setChecked(enabled);
    btn->blockSignals(false);

    QString text = baseTitle;
    if (enabled) {
        text.prepend(check);
    }
    btn->setText(text);
}

void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // English
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], p.titleDefault);
        }
    }

    // Optional
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Spec
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Flag
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
        }
    }
}

void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ① settings.enabled を更新
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        Settings::instance().enabled[key] = checked;
    }

    // ② UI 更新（✓ の付け外し）
    QString baseTitle = button->text();
    const QString check = QString::fromUtf8("✓ ");

    // ✓ を除去して baseTitle を作る
    if (baseTitle.startsWith(check)) {
        baseTitle.remove(0, check.size());
    }

    updateButtonUI(button, checked, baseTitle);
}







/* ============================================================
 *  CustomizeDialog API
 * ============================================================ */
QString Settings::getTitleFormat(int index)
{
    return instance().titleFormat[index];
}

QString Settings::getFileNameFormat(int index)
{
    return instance().fileNameFormat[index];
}

void Settings::setTitleFormatValue(int index, const QString &value)
{
    instance().titleFormat[index] = value;
}

void Settings::setFileNameFormatValue(int index, const QString &value)
{
    instance().fileNameFormat[index] = value;
}

/* ============================================================
 *  CheckBox flags
 * ============================================================ */
bool Settings::tagSpaceFlag()
{
    return instance().enabled[Constants::KEY_TAG_SPACE];
}

bool Settings::nameSpaceFlag()
{
    return instance().enabled[Constants::KEY_NAME_SPACE];
}

bool Settings::multiGuiFlag()
{
    return instance().enabled[Constants::KEY_MULTI_GUI];
}

bool Settings::kozaSeparationFlag()
{
    return instance().enabled[Constants::KEY_KOZA_SEPARATION];
}

void Settings::setTagSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_TAG_SPACE] = flag;
}

void Settings::setNameSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_NAME_SPACE] = flag;
}

void Settings::setMultiGuiFlag(bool flag)
{
    instance().enabled[Constants::KEY_MULTI_GUI] = flag;
}

void Settings::setKozaSeparationFlag(bool flag)
{
    instance().enabled[Constants::KEY_KOZA_SEPARATION] = flag;
}

void Settings::loadMainWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    mainWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMainWindow(const QByteArray &geometry)
{
    mainWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}

void Settings::loadMessageWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMessageWindow(const QByteArray &geometry)
{
    messageWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}







[100%] Linking CXX executable CaptureStream2
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::formats(QString, QString&, QString&)':
customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x5f): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x8f): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::loadSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x43): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x56): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x9b): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xae): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xea): undefined reference to `Settings::tagSpaceFlag()'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x10c): undefined reference to `Settings::nameSpaceFlag()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::saveSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x5b): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x97): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xc0): undefined reference to `Settings::setTagSpaceFlag(bool)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xf2): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x12e): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x157): undefined reference to `Settings::setNameSpaceFlag(bool)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::saveGui()':
mainwindow.cpp:(.text._ZN10MainWindow7saveGuiEv+0x5a): undefined reference to `Settings::saveMainWindow(QByteArray const&)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeScramble()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeScrambleEv+0x33): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeSettings()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeSettingsEv+0x30): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::download()':
mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x2a): undefined reference to `MainWindow::collectEnglishSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x36): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x42): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x4e): undefined reference to `MainWindow::collectCheckBoxSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/messagewindow.cpp.o: in function `MessageWindow::~MessageWindow()':
messagewindow.cpp:(.text._ZN13MessageWindowD2Ev+0x8b): undefined reference to `Settings::saveMessageWindow(QByteArray const&)'
collect2: error: ld returned 1 exit status
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:457: CaptureStream2] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2





#pragma once
#include <QString>
#include <QStringList>
#include <QMap>
#include "constants.h"
#include "settings.h"

// ===== 実行時に使う番組データ =====
struct RuntimeProgram {
    QString id;      // 実際に使用する番組ID
    QString title;   // 実際に使用するタイトル
    bool enabled;    // 実行対象かどうか
};

class RuntimeConfig
{
public:
    RuntimeConfig();

    // Settings → RuntimeConfig へコピー
    void applySettings(const Settings &s);

    // CLI オプションで上書き
    void applyCommandLine(const QMap<QString, QString> &opts);

    // ===== 実行時の最終値 =====
    RuntimeProgram english[Constants::EnglishCount];
    RuntimeProgram optional[Constants::OptionalCount];
    RuntimeProgram spec[Constants::SpecCount];
    bool checkBox[Constants::FlagCount];

    // ===== その他設定 =====
    QString saveFolder;
    QString audioExtension;

    // 最新番組一覧（ProgramEntry に変更）
    QMap<QString, Constants::ProgramEntry> latestProgramMap;

    // name_map / id_map / thumbnail_map
    QMap<QString, QString> id_map;
    QMap<QString, QString> name_map;
    QMap<QString, QString> thumbnail_map;
};


#include "runtimeconfig.h"
#include "constants.h"

RuntimeConfig::RuntimeConfig()
{
}

void RuntimeConfig::applySettings(const Settings &s)
{
    // ===== English =====
    for (int i = 0; i < Constants::EnglishCount; i++) {
        const auto &p = Constants::EnglishPrograms[i];

        english[i].enabled = s.enabled[p.keyEnabled];
        english[i].id      = p.idDefault;       // English は固定
        english[i].title   = p.titleDefault;    // English は固定
    }

    // ===== Optional =====
    for (int i = 0; i < Constants::OptionalCount; i++) {
        const auto &p = Constants::OptionalPrograms[i];

        optional[i].enabled = s.enabled[p.keyEnabled];
        optional[i].id      = s.ids[p.keyId];
        optional[i].title   = s.titles[p.keyTitle];
    }

    // ===== Spec =====
    for (int i = 0; i < Constants::SpecCount; i++) {
        const auto &p = Constants::SpecPrograms[i];

        spec[i].enabled = s.enabled[p.keyEnabled];
        spec[i].id      = s.ids[p.keyId];
        spec[i].title   = s.titles[p.keyTitle];
    }

    // ===== Flag（チェックボックス）=====
    for (int i = 0; i < Constants::FlagCount; i++) {
        const auto &p = Constants::FlagSettings[i];
        checkBox[i] = s.enabled[p.keyEnabled];
    }

    // ===== その他設定 =====
    saveFolder     = s.saveFolder;
    audioExtension = s.audioExtension;
}

void RuntimeConfig::applyCommandLine(const QMap<QString, QString> &opts)
{
    // --save-folder
    if (opts.contains("save-folder"))
        saveFolder = opts["save-folder"];

    // --audio-ext
    if (opts.contains("audio-ext"))
        audioExtension = opts["audio-ext"];

    // --enable=xxx
    if (opts.contains("enable")) {
        QString key = opts["enable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = true;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = true;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = true;
    }

    // --disable=xxx
    if (opts.contains("disable")) {
        QString key = opts["disable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = false;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = false;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = false;
    }
}








#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class ScrambleDialog;
}

class ScrambleDialog : public QDialog {
    Q_OBJECT

public:
    explicit ScrambleDialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~ScrambleDialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::ScrambleDialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateOptional(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};


#include "scrambledialog.h"
#include "ui_scrambledialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

ScrambleDialog::ScrambleDialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::ScrambleDialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4,
              ui->edit5, ui->edit6, ui->edit7, ui->edit8 };

    // ===== OptionalPrograms の ID を Settings から復元 =====
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++) {
        const auto &p = Constants::OptionalPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== フラグ復元 =====
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

ScrambleDialog::~ScrambleDialog()
{
    delete ui;
}

void ScrambleDialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
}

QString ScrambleDialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = OPT_PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.optionals;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit *edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void ScrambleDialog::accept()
{
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++)
        updateOptional(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void ScrambleDialog::updateLabels()
{
    std::array<QLabel*, Constants::OPT_PRESET_SIZE> labels = {
        ui->label_2, ui->label_3, ui->label_4, ui->label_5,
        ui->label_6, ui->label_7, ui->label_8, ui->label_9
    };

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void ScrambleDialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {

            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void ScrambleDialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3] + "\n" +
        "５：" + titles[4] + "\n" +
        "６：" + titles[5] + "\n" +
        "７：" + titles[6] + "\n" +
        "８：" + titles[7];

    if (QMessageBox::question(this, tr("任意番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
            settings.optionals[i] = edits[i]->text();
    }
}

QString ScrambleDialog::updateOptional(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = OptionalPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}









#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class Settingsdialog;
}

class Settingsdialog : public QDialog {
    Q_OBJECT

public:
    explicit Settingsdialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~Settingsdialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::Settingsdialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateSpecial(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};



#include "settingsdialog.h"
#include "ui_settingsdialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

Settingsdialog::Settingsdialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::Settingsdialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4 };

    // ===== 特番（SpecPrograms）を Settings から復元 =====
    for (int i = 0; i < Constants::PRESET_SIZE; i++) {
        const auto &p = Constants::SpecPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== チェックボックスフラグ =====
    ui->checkBox->setChecked(settings.enabled[Constants::KEY_MULTI_GUI]);
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

Settingsdialog::~Settingsdialog()
{
    delete ui;
}

void Settingsdialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
    settings.enabled[Constants::KEY_MULTI_GUI] = ui->checkBox->isChecked();
}

QString Settingsdialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.specials;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit* edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void Settingsdialog::accept()
{
    for (int i = 0; i < Constants::PRESET_SIZE; i++)
        updateSpecial(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void Settingsdialog::updateLabels()
{
    std::array<QLabel*, Constants::PRESET_SIZE> labels =
        { ui->label_2, ui->label_3, ui->label_4, ui->label_5 };

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void Settingsdialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {
            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void Settingsdialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3];

    if (QMessageBox::question(this, tr("特別番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::PRESET_SIZE; ++i)
            settings.specials[i] = edits[i]->text();
    }
}

QString Settingsdialog::updateSpecial(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = SpecPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}






void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry 復元
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // ===== English =====
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);
            btn->setText(p.titleDefault);   // 固定タイトル
        }
    }

    // ===== Optional =====
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Spec =====
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Flag（チェックボックス）=====
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
            // ラベルは UI 側の固定値を使うので setText は不要
        }
    }
}

void MainWindow::saveGui()
{
    auto &s = Settings::instance();

    // geometry 保存
    s.saveMainWindow(saveGeometry());

    // enabled の書き戻し
    for (const auto &p : Constants::EnglishPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::OptionalPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::SpecPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::FlagSettings) {
        if (!p.objectName.isEmpty()) {
            if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = cb->isChecked();
            }
        }
    }

    // 最後に settings.ini へ保存
    s.save();
}





// Settings.h

#pragma once
#include <QString>
#include <QSettings>
#include <QMap>
#include <QVector>
#include <QByteArray>
#include "constants.h"

class Settings
{
public:
    static Settings& instance();

    void load();
    void save();

    // ===== MainWindow / MessageWindow =====
    void loadMainWindow();
    void saveMainWindow(const QByteArray &geometry);

    void loadMessageWindow();
    void saveMessageWindow(const QByteArray &geometry);

    // ===== 基本設定 =====
    QString audioExtension;
    QString ffmpegFolder;
    QString saveFolder;

    // ===== ProgramEntry の値（enabled / id / title）=====
    // keyEnabled → enabled
    QMap<QString, bool> enabled;

    // keyId → id
    QMap<QString, QString> ids;

    // keyTitle → title
    QMap<QString, QString> titles;

    // ===== optional / spec のプリセット =====
    std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
    std::array<QString, Constants::PRESET_SIZE> specials;

    // ===== geometry =====
    QByteArray mainWindowGeometry;
    QByteArray messageWindowGeometry;

    // ===== CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    static QString getTitleFormat(int index);
    static QString getFileNameFormat(int index);

    static void setTitleFormatValue(int index, const QString &value);
    static void setFileNameFormatValue(int index, const QString &value);

    // ===== CheckBox flags =====
    static bool tagSpaceFlag();
    static bool nameSpaceFlag();
    static bool multiGuiFlag();
    static bool kozaSeparationFlag();

    static void setTagSpaceFlag(bool flag);
    static void setNameSpaceFlag(bool flag);
    static void setMultiGuiFlag(bool flag);
    static void setKozaSeparationFlag(bool flag);

private:
    Settings();
    Settings(const Settings&) = delete;
    Settings& operator=(const Settings&) = delete;

    // 内部ヘルパー
    void loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
    void saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
};


//settings.cpp
#include "settings.h"
#include <QSettings>

Settings::Settings()
{
}

Settings& Settings::instance()
{
    static Settings inst;
    return inst;
}

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     loadProgramEntry(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}

void Settings::save()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて保存
    for (const auto &p : Constants::EnglishPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     saveProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     saveProgramEntry(p, ini);

    ini.setValue(Constants::KEY_AudioExtension, audioExtension);

    if (saveFolder.isNull()) ini.remove(Constants::KEY_SaveFolder);
    else ini.setValue(Constants::KEY_SaveFolder, saveFolder);

    if (ffmpegFolder.isNull()) ini.remove(Constants::KEY_FfmpegFolder);
    else ini.setValue(Constants::KEY_FfmpegFolder, ffmpegFolder);

    ini.setValue("geometry", mainWindowGeometry);

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", messageWindowGeometry);
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        ini.setValue(QString("optional%1").arg(i + 1), optionals[i]);
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        ini.setValue(QString("special%1").arg(i + 1), specials[i]);
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        ini.setValue(t.key, titleFormat[i]);

        const auto &f = Constants::FILENAME_ITEMS[i];
        ini.setValue(f.key, fileNameFormat[i]);
    }
    ini.endGroup();
}

/* ============================================================
 * ProgramEntry 読み込み
 * ============================================================ */
void Settings::loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    // enabled
    enabled[p.keyEnabled] =
        ini.value(p.keyEnabled, p.enabledDefault).toBool();

    // id
    if (!p.keyId.isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // title
    if (!p.keyTitle.isEmpty())
        titles[p.keyTitle] = ini.value(p.keyTitle, p.titleDefault).toString();
}

/* ============================================================
 * ProgramEntry 保存
 * ============================================================ */
void Settings::saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    ini.setValue(p.keyEnabled, enabled[p.keyEnabled]);

    if (!p.keyId.isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!p.keyTitle.isEmpty())
        ini.setValue(p.keyTitle, titles[p.keyTitle]);
}






class Settings {
public:
    static Settings& instance();

    // 既存のマップ
    QMap<QString, bool> englishEnabled;
    QMap<QString, bool> optionalEnabled;
    QMap<QString, bool> specEnabled;
    QMap<QString, bool> checkBoxEnabled;

    // ★ 追加：横断 enabled キャッシュ（INI に保存しない）
    QMap<QString, bool> enabled;

    void buildUnifiedEnabled();   // load() の後に呼ぶ
    void syncEnabledBack();       // save() の前に呼ぶ

    // ...
};


void Settings::buildUnifiedEnabled()
{
    enabled.clear();

    // English
    for (const auto& p : Constants::EnglishPrograms) {
        enabled[p.key] = englishEnabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        enabled[p.keyEnabled] = optionalEnabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        enabled[p.keyEnabled] = specEnabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        enabled[c.keyEnabled] = checkBoxEnabled[c.keyEnabled];
    }
}


void Settings::syncEnabledBack()
{
    // English
    for (const auto& p : Constants::EnglishPrograms) {
        englishEnabled[p.key] = enabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        optionalEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        specEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        checkBoxEnabled[c.keyEnabled] = enabled[c.keyEnabled];
    }
}



buildUnifiedEnabled();


syncEnabledBack();


QMap<QString, QString> objectToKey;


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    using namespace Constants;

    // English
    for (const auto& p : EnglishPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.key;
    }

    // Optional
    for (const auto& p : OptionalPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // Spec
    for (const auto& p : SpecPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // CheckBox
    for (const auto& c : CheckBoxSettings) {
        if (!c.objectName.isEmpty())
            objectToKey[c.objectName] = c.keyEnabled;
    }
}


void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ★ 横断 enabled に書き込むだけ
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        settings.enabled[key] = checked;
    }

    // UI のチェックマーク処理
    QString text = button->text();
    const QString check = QString::fromUtf8("✓ ");

    if (text.startsWith(check))
        text.remove(0, check.size());

    if (checked)
        text.prepend(check);

    button->setText(text);
}
