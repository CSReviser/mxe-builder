
void RuntimeConfig::applyCommandLine(const CliOptions& cli)
{
    // 1. 値を取るオプション
    for (auto it = cli.valueOptions.constBegin(); it != cli.valueOptions.constEnd(); ++it) {
        const QString& key = it.key();
        const QString& value = it.value();
        set(key, value);   // ← RuntimeConfig の API に合わせる
    }

    // 2. フラグオプション
    for (const QString& key : cli.enabledKeys) {
        set(key, true);
    }

    // 3. プログラムID
    cliProgramIds.clear();
    for (const QString& id : cli.programIds) {
        cliProgramIds.push_back(id);   // std::vector<QString> に追加
    }
}


[ 72%] Building CXX object CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp: In member function ‘void RuntimeConfig::applyCommandLine(const CliOptions&)’:
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:103:13: error: ‘const struct CliOptions’ has no member named ‘titleTagFormat’
  103 |     if (cli.titleTagFormat)
      |             ^~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:104:34: error: ‘const struct CliOptions’ has no member named ‘titleTagFormat’
  104 |         cliTitleTagFormat = *cli.titleTagFormat;
      |                                  ^~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:106:13: error: ‘const struct CliOptions’ has no member named ‘fileNameFormat’
  106 |     if (cli.fileNameFormat)
      |             ^~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:107:34: error: ‘const struct CliOptions’ has no member named ‘fileNameFormat’
  107 |         cliFileNameFormat = *cli.fileNameFormat;
      |                                  ^~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:109:13: error: ‘const struct CliOptions’ has no member named ‘outputFolder’
  109 |     if (cli.outputFolder)
      |             ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:110:32: error: ‘const struct CliOptions’ has no member named ‘outputFolder’
  110 |         cliOutputFolder = *cli.outputFolder;
      |                                ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:112:13: error: ‘const struct CliOptions’ has no member named ‘extension’
  112 |     if (cli.extension)
      |             ^~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:113:29: error: ‘const struct CliOptions’ has no member named ‘extension’
  113 |         cliExtension = *cli.extension;
      |                             ^~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:116:29: error: no match for ‘operator=’ (operand types are ‘std::vector<QString>’ and ‘QVector<QString>’ {aka ‘const QList<QString>’})
  116 |         cliProgramIds = cli.programIds;
      |                             ^~~~~~~~~~
In file included from /usr/include/c++/11/vector:72,
                 from /usr/include/c++/11/functional:62,
                 from /opt/qt6/include/QtCore/qchar.h:9,
                 from /opt/qt6/include/QtCore/qstring.h:14,
                 from /opt/qt6/include/QtCore/QString:1,
                 from /home/kazuo/cs/CaptureStream2/runtimeconfig.h:27,
                 from /home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:24:
/usr/include/c++/11/bits/vector.tcc:198:5: note: candidate: ‘std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const std::vector<_Tp, _Alloc>&) [with _Tp = QString; _Alloc = std::allocator<QString>]’
  198 |     vector<_Tp, _Alloc>::
      |     ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/vector.tcc:199:42: note:   no known conversion for argument 1 from ‘QVector<QString>’ {aka ‘const QList<QString>’} to ‘const std::vector<QString>&’
  199 |     operator=(const vector<_Tp, _Alloc>& __x)
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from /usr/include/c++/11/vector:67,
                 from /usr/include/c++/11/functional:62,
                 from /opt/qt6/include/QtCore/qchar.h:9,
                 from /opt/qt6/include/QtCore/qstring.h:14,
                 from /opt/qt6/include/QtCore/QString:1,
                 from /home/kazuo/cs/CaptureStream2/runtimeconfig.h:27,
                 from /home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:24:
/usr/include/c++/11/bits/stl_vector.h:709:7: note: candidate: ‘std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::vector<_Tp, _Alloc>&&) [with _Tp = QString; _Alloc = std::allocator<QString>]’
  709 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |       ^~~~~~~~
/usr/include/c++/11/bits/stl_vector.h:709:26: note:   no known conversion for argument 1 from ‘QVector<QString>’ {aka ‘const QList<QString>’} to ‘std::vector<QString>&&’
  709 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      |                 ~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:730:7: note: candidate: ‘std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::initializer_list<_Tp>) [with _Tp = QString; _Alloc = std::allocator<QString>]’
  730 |       operator=(initializer_list<value_type> __l)
      |       ^~~~~~~~
/usr/include/c++/11/bits/stl_vector.h:730:46: note:   no known conversion for argument 1 from ‘QVector<QString>’ {aka ‘const QList<QString>’} to ‘std::initializer_list<QString>’
  730 |       operator=(initializer_list<value_type> __l)
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:309: CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2




#ifndef CLIOPTIONS_H
#define CLIOPTIONS_H

#include <QHash>
#include <QVector>
#include <QString>

struct CliOptions {
    QVector<QString> programIds;
    QHash<QString, QString> valueOptions;
    QVector<QString> enabledKeys;
};

#endif







#include "commandlineparser.h"
#include "constants_cli.h"
#include <QHash>

namespace {

// OPTION_TABLE を QString 化して高速検索できるようにする
static const QHash<QString, const Constants::CliOption*>& optionMap()
{
    static const QHash<QString, const Constants::CliOption*> map = []{
        QHash<QString, const Constants::CliOption*> m;
        for (int i = 0; i < Constants::getOptionTableCount(); ++i) {
            const auto& opt = Constants::OPTION_TABLE[i];
            // OPTION_TABLE の name は UTF-8 とみなす
            m.insert(QString::fromUtf8(opt.name), &opt);
        }
        return m;
    }();
    return map;
}

} // namespace


SimpleCliOptions CommandLineParser::parseSimple(int argc, char* argv[])
{
    SimpleCliOptions opts;

    for (int i = 1; i < argc; ++i) {
        // Windows の argv は ANSI（CP932）なので Local8Bit
        QString arg = QString::fromLocal8Bit(argv[i]);
        if (arg == "-nogui" || arg == "--nogui") {
            opts.nogui = true;
        }
    }
    return opts;
}


CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    for (int i = 1; i < argc; ++i) {
        // Windows の argv は ANSI（CP932）なので Local8Bit
        QString arg = QString::fromLocal8Bit(argv[i]);

        // OPTION_TABLE の name は UTF-8 とみなす
        const Constants::CliOption* opt = optionMap().value(arg, nullptr);

        if (!opt) {
            if (!arg.startsWith("-")) {
                opts.programIds.push_back(arg);
            }
            continue;
        }

        // keyOption は UTF-8 とみなす
        QString key = QString::fromUtf8(opt->keyOption);

        // -nogui は main の分岐にも使うので特別扱い
        if (key == QString::fromUtf8(Constants::KEY_NOGUI)) {
            opts.nogui = true;
        }

        if (opt->requiresValue) {
            if (i + 1 < argc) {
                QString value = QString::fromLocal8Bit(argv[++i]);
                opts.optionValues[key] = value;
            }
        } else {
            opts.enabledFlags.insert(key);
        }
    }

    return opts;
}



#pragma once
#include <QString>
#include <QMap>
#include <QSet>
#include <vector>

struct SimpleCliOptions {
    bool nogui = false;
};

struct CliOptions {
    bool nogui = false;

    QMap<QString, QString> optionValues;
    QSet<QString> enabledFlags;
    std::vector<QString> programIds;
};

class CommandLineParser {
public:
    static SimpleCliOptions parseSimple(int argc, char* argv[]);
    static CliOptions parse(int argc, char* argv[]);
};


#include "commandlineparser.h"
#include "constants.h"
#include <QString>

CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    auto findOption = [&](const QString& arg) -> const Constants::CliOption* {
        for (int i = 0; i < Constants::getOptionTableCount(); ++i) {
            if (arg == Constants::OPTION_TABLE[i].name)
                return &Constants::OPTION_TABLE[i];
        }
        return nullptr;
    };

    for (int i = 1; i < argc; ++i) {
        QString arg = QString::fromUtf8(argv[i]);
        const Constants::CliOption* opt = findOption(arg);

        if (!opt) {
            // プログラムIDとして扱う
            opts.programIds.push_back(arg);
            continue;
        }

        // 値を取るオプション
        if (opt->requiresValue) {
            if (i + 1 >= argc)
                break;

            QString value = QString::fromUtf8(argv[++i]);

            // valueOptions に登録
            opts.valueOptions.insert(opt->keyOption, value);
        }
        else {
            // フラグオプション
            opts.enabledKeys.push_back(opt->keyOption);
        }
    }

    return opts;
}





#include "clicontroller.h"
#include "commandlineparser.h"
#include "programrepository.h"
#include "recordingcore.h"

CLIController::CLIController(const Settings& settings, int argc, char** argv)
    : m_settings(settings)
    , m_argc(argc)
    , m_argv(argv)
{
}

int CLIController::run()
{
    // 1. CLI オプション解析
    CliOptions opts = CommandLineParser::parse(m_argc, m_argv);

    // 2. オプション検証
    if (!validateOptions(opts)) {
        return 1;
    }

    // 3. RuntimeConfig 構築
    RuntimeConfig config(m_settings);

    // 4. CLI 上書き適用
    applyCliOverrides(config, opts);

    // 5. 実行（RecordingCore は QThread）
    RecordingCore core(config);

    core.start();   // QThread の開始
    core.wait();    // 終了待ち

    return 0;       // とりあえず仮
}

bool CLIController::validateOptions(const CliOptions& opts) const
{
    for (auto it = opts.valueOptions.constBegin(); it != opts.valueOptions.constEnd(); ++it) {
        if (it.value().isEmpty()) {
            return false;
        }
    }
    return true;
}

bool CLIController::validateProgramIds(const CliOptions& opts) const
{
    const ProgramRepository& repo = ProgramRepository::instance();
    const QMap<QString, QString>& idMap = repo.id_map;

    for (const QString& id : opts.programIds) {
        if (!idMap.contains(id)) {
            return false;
        }
    }
    return true;
}

void CLIController::applyCliOverrides(RuntimeConfig& config, const CliOptions& opts) const
{
    for (auto it = opts.valueOptions.constBegin(); it != opts.valueOptions.constEnd(); ++it) {
        config.set(it.key(), it.value());   // setValue → set に修正
    }

    for (const QString& key : opts.enabledKeys) {
        config.set(key, true);
    }
}





class RecordingCore : public QThread {
	Q_OBJECT


public:
	RecordingCore( const RuntimeConfig& runtime );
	~RecordingCore() {}



[  8%] Building CXX object CMakeFiles/CaptureStream2.dir/clicontroller.cpp.o
/home/kazuo/cs/CaptureStream2/clicontroller.cpp: In member function ‘int CLIController::run()’:
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:20:23: error: ‘CommandLineParser’ has not been declared
   20 |     CliOptions opts = CommandLineParser::parse(m_argc, m_argv);
      |                       ^~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:36:40: error: no matching function for call to ‘RecordingCore::RecordingCore(RuntimeConfig*)’
   36 |     RecordingCore RecordingCore(&config);
      |                                        ^
In file included from /home/kazuo/cs/CaptureStream2/clicontroller.cpp:3:
/home/kazuo/cs/CaptureStream2/recordingcore.h:41:9: note: candidate: ‘RecordingCore::RecordingCore(const RuntimeConfig&)’
   41 |         RecordingCore( const RuntimeConfig& runtime );
      |         ^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/recordingcore.h:41:45: note:   no known conversion for argument 1 from ‘RuntimeConfig*’ to ‘const RuntimeConfig&’
   41 |         RecordingCore( const RuntimeConfig& runtime );
      |                        ~~~~~~~~~~~~~~~~~~~~~^~~~~~~
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:37:26: error: ‘class RecordingCore’ has no member named ‘runHeadless’
   37 |     return RecordingCore.runHeadless();
      |                          ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/clicontroller.cpp: In member function ‘bool CLIController::validateOptions(const CliOptions&) const’:
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:43:25: error: ‘const struct CliOptions’ has no member named ‘optionValues’
   43 |     for (auto it = opts.optionValues.constBegin(); it != opts.optionValues.constEnd(); ++it) {
      |                         ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:43:63: error: ‘const struct CliOptions’ has no member named ‘optionValues’
   43 |   for (auto it = opts.optionValues.constBegin(); it != opts.optionValues.constEnd(); ++it) {
      |                                                             ^~~~~~~~~~~~

/home/kazuo/cs/CaptureStream2/clicontroller.cpp: In member function ‘bool CLIController::validateProgramIds(const CliOptions&) const’:
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:68:49: error: invalid initialization of reference of type ‘const QHash<QString, QString>&’ from expression of type ‘QMap<QString, QString>’
   68 |     const QHash<QString, QString>& idMap = repo.id_map;
      |                                            ~~~~~^~~~~~
/home/kazuo/cs/CaptureStream2/clicontroller.cpp: In member function ‘void CLIController::applyCliOverrides(RuntimeConfig&, const CliOptions&) const’:
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:82:25: error: ‘const struct CliOptions’ has no member named ‘optionValues’
   82 |     for (auto it = opts.optionValues.constBegin(); it != opts.optionValues.constEnd(); ++it) {
      |                         ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:82:63: error: ‘const struct CliOptions’ has no member named ‘optionValues’
   82 |   for (auto it = opts.optionValues.constBegin(); it != opts.optionValues.constEnd(); ++it) {
      |                                                             ^~~~~~~~~~~~

/home/kazuo/cs/CaptureStream2/clicontroller.cpp:86:16: error: ‘class RuntimeConfig’ has no member named ‘setValue’
   86 |         config.setValue(key, value);
      |                ^~~~~~~~
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:90:36: error: ‘const struct CliOptions’ has no member named ‘enabledFlags’; did you mean ‘enabledKeys’?
   90 |     for (const QString& key : opts.enabledFlags) {
      |                                    ^~~~~~~~~~~~
      |                                    enabledKeys
/home/kazuo/cs/CaptureStream2/clicontroller.cpp:91:16: error: ‘class RuntimeConfig’ has no member named ‘setValue’
   91 |         config.setValue(key, true);
      |                ^~~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:337: CMakeFiles/CaptureStream2.dir/clicontroller.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2



// clicontroller.h
class CLIController {
public:
    CLIController(const Settings& settings, int argc, char** argv);

private:
    const Settings& m_settings;   // ← 参照にする
    int m_argc;
    char** m_argv;
};

// clicontroller.cpp
CLIController::CLIController(const Settings& settings, int argc, char** argv)
    : m_settings(settings)
    , m_argc(argc)
    , m_argv(argv)
{}
#include "commandlineparser.h"


const QHash<QString, QString>& idMap = repo.id_map;








ProgramRepository.h 
public:
    void start();          // 起動（非同期開始）
    bool waitUntilReady(); // CLI用同期待機
    bool isReady() const;


ProgramRepository.cpp
void ProgramRepository::start()
{
    if (m_started)
        return;

    m_started = true;
    updatePrograms(); // ← 今まで呼んでいたやつ
}

bool ProgramRepository::waitUntilReady()
{
    if (m_ready)
        return true;

    QEventLoop loop;
    QObject::connect(this, &ProgramRepository::programListUpdated,
                     &loop, &QEventLoop::quit);
    loop.exec();
    return m_ready;
}

bool ProgramRepository::isReady() const
{
    return m_ready;
}

main
int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);

    // ★ Repositoryをアプリとして起動（待たない）
    ProgramRepository::instance().start();

    Settings settings;
    settings.load();

    if (isCliMode(argc, argv)) {

        // CLIだけ待つ
        if (!ProgramRepository::instance().waitUntilReady()) {
            qCritical() << "Failed to initialize program repository";
            return 1;
        }

        CLIController cli(settings, argc, argv);
        return cli.run();
    }
    else {
        QApplication guiApp(argc, argv);

        MainWindow w;
        w.show();

        return guiApp.exec();
    }
}


CLIController
int CLIController::run()
{
    // ★ もう Repository は準備済みという前提

    CliOptions opts = CommandLineParser::parse(m_argc, m_argv);

    if (!validateOptions(opts)) {
        qWarning() << "CLI option validation failed.";
        return 1;
    }

    RuntimeConfig config;
    config.applySettings(m_settings);

    applyCliOverrides(config, opts);

    RecordingOrchestrator orchestrator(&config);
    return orchestrator.runHeadless();
}



// clicontroller.h
#pragma once

#include <QString>
#include "settings.h"
#include "commandlineparser.h"
#include "runtimeconfig.h"

class CLIController
{
public:
    CLIController(const Settings& settings, int argc, char* argv[]);

    int run();

private:
    bool validateOptions(const CliOptions& opts) const;
    bool validateProgramIds(const CliOptions& opts) const;
    void applyCliOverrides(RuntimeConfig& config, const CliOptions& opts) const;

private:
    Settings m_settings;
    int m_argc;
    char** m_argv;
};


// clicontroller.cpp
#include "clicontroller.h"
#include "programrepository.h"
#include "recordingorchestrator.h"

#include <QEventLoop>
#include <QDebug>

CLIController::CLIController(const Settings& settings, int argc, char* argv[])
    : m_settings(settings)
    , m_argc(argc)
    , m_argv(argv)
{
}

int CLIController::run()
{
    // 1. 番組リポジトリ更新を開始（非同期）
    ProgramRepository& repo = ProgramRepository::instance();
    QEventLoop loop;

    QObject::connect(&repo, &ProgramRepository::programListUpdated,
                     &loop, &QEventLoop::quit);

    repo.updatePrograms();
    loop.exec(); // 完了まで待機

    // 2. コマンドライン解析（抽象化済みパーサー）
    CliOptions opts = CommandLineParser::parse(m_argc, m_argv);

    // 3. オプション妥当性確認
    if (!validateOptions(opts)) {
        qWarning() << "CLI option validation failed.";
        return 1;
    }

    // 4. Settings → RuntimeConfig へ反映
    RuntimeConfig config;
    config.applySettings(m_settings);

    // 5. CLI オプションで RuntimeConfig を上書き
    applyCliOverrides(config, opts);

    // 6. 実行
    RecordingOrchestrator orchestrator(&config);
    return orchestrator.runHeadless();
}

bool CLIController::validateOptions(const CliOptions& opts) const
{
    // 値付きオプションの簡易チェック（空文字など）
    for (auto it = opts.optionValues.constBegin(); it != opts.optionValues.constEnd(); ++it) {
        const QString& key = it.key();
        const QString& value = it.value();

        if (value.isEmpty()) {
            qWarning() << "Empty value for option key:" << key;
            return false;
        }
        // 必要なら key ごとの詳細チェックをここに追加
    }

    // 番組IDの妥当性確認
    if (!validateProgramIds(opts)) {
        return false;
    }

    return true;
}

bool CLIController::validateProgramIds(const CliOptions& opts) const
{
    ProgramRepository& repo = ProgramRepository::instance();

    // ProgramRepository 側に id_map へのアクセサがある前提
    // 例: const QHash<QString, QString>& ProgramRepository::idMap() const;
    const QHash<QString, QString>& idMap = repo.idMap();

    for (const QString& id : opts.programIds) {
        if (!idMap.contains(id)) {
            qWarning() << "Unknown program ID:" << id;
            return false;
        }
    }
    return true;
}

void CLIController::applyCliOverrides(RuntimeConfig& config, const CliOptions& opts) const
{
    // 値付きオプション
    for (auto it = opts.optionValues.constBegin(); it != opts.optionValues.constEnd(); ++it) {
        const QString& key = it.key();
        const QString& value = it.value();
        // RuntimeConfig が QString キーを受け取る前提
        config.setValue(key, value);
    }

    // フラグ（bool）
    for (const QString& key : opts.enabledFlags) {
        config.setValue(key, true);
    }

    // 番組ID（必要に応じて RuntimeConfig に渡す）
    if (!opts.programIds.empty()) {
        // 例: 最初の ID を対象とする場合
        // config.setValue("program_id", opts.programIds.front());
        // あるいは専用 API があればそちらを呼ぶ
    }
}









#include "commandlineparser.h"
#include "constants_cli.h"
#include <QHash>

namespace {

// OPTION_TABLE を QString 化して高速検索できるようにする
static const QHash<QString, const Constants::CliOption*>& optionMap()
{
    static const QHash<QString, const Constants::CliOption*> map = []{
        QHash<QString, const Constants::CliOption*> m;
        for (int i = 0; i < Constants::getOptionTableCount(); ++i) {
            const auto& opt = Constants::OPTION_TABLE[i];
            // OPTION_TABLE の name は UTF-8 とみなす
            m.insert(QString::fromUtf8(opt.name), &opt);
        }
        return m;
    }();
    return map;
}

} // namespace


SimpleCliOptions CommandLineParser::parseSimple(int argc, char* argv[])
{
    SimpleCliOptions opts;

    for (int i = 1; i < argc; ++i) {
        // Windows の argv は ANSI（CP932）なので Local8Bit
        QString arg = QString::fromLocal8Bit(argv[i]);
        if (arg == "-nogui" || arg == "--nogui") {
            opts.nogui = true;
        }
    }
    return opts;
}


CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    for (int i = 1; i < argc; ++i) {
        // Windows の argv は ANSI（CP932）なので Local8Bit
        QString arg = QString::fromLocal8Bit(argv[i]);

        // OPTION_TABLE の name は UTF-8 とみなす
        const Constants::CliOption* opt = optionMap().value(arg, nullptr);

        if (!opt) {
            if (!arg.startsWith("-")) {
                opts.programIds.push_back(arg);
            }
            continue;
        }

        // keyOption は UTF-8 とみなす
        QString key = QString::fromUtf8(opt->keyOption);

        // -nogui は main の分岐にも使うので特別扱い
        if (key == QString::fromUtf8(Constants::KEY_NOGUI)) {
            opts.nogui = true;
        }

        if (opt->requiresValue) {
            if (i + 1 < argc) {
                QString value = QString::fromLocal8Bit(argv[++i]);
                opts.optionValues[key] = value;
            }
        } else {
            opts.enabledFlags.insert(key);
        }
    }

    return opts;
}


#pragma once
#include <QString>
#include <QMap>
#include <QSet>
#include <vector>

struct SimpleCliOptions {
    bool nogui = false;
};

struct CliOptions {
    bool nogui = false;

    QMap<QString, QString> optionValues;
    QSet<QString> enabledFlags;
    std::vector<QString> programIds;
};

class CommandLineParser {
public:
    static SimpleCliOptions parseSimple(int argc, char* argv[]);
    static CliOptions parse(int argc, char* argv[]);
};






h
#pragma once
#include <QString>
#include <QMap>
#include <QSet>
#include <vector>

struct SimpleCliOptions {
    bool nogui = false;
};

struct CliOptions {
    bool nogui = false;

    // 値を取るオプション（キーは const char*）
    QMap<const char*, QString> optionValues;

    // 値を取らないフラグ（キーは const char*）
    QSet<const char*> enabledFlags;

    // プログラムID候補
    std::vector<QString> programIds;
};

class CommandLineParser {
public:
    // main() が使う：-nogui だけ判定
    static SimpleCliOptions parseSimple(int argc, char* argv[]);

    // CLIController が使う：全オプション抽象パース
    static CliOptions parse(int argc, char* argv[]);
};


cpp
#include "commandlineparser.h"
#include "constants_cli.h"

SimpleCliOptions CommandLineParser::parseSimple(int argc, char* argv[])
{
    SimpleCliOptions opts;

    for (int i = 1; i < argc; ++i) {
        QString arg = QString::fromLocal8Bit(argv[i]);
        if (arg == "-nogui" || arg == "--nogui") {
            opts.nogui = true;
        }
    }
    return opts;
}

CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    auto findOption = [&](const QString& arg) -> const Constants::CliOption* {
        for (int i = 0; i < Constants::getOptionTableCount(); ++i) {
            if (arg == Constants::OPTION_TABLE[i].name) {
                return &Constants::OPTION_TABLE[i];
            }
        }
        return nullptr;
    };

    for (int i = 1; i < argc; ++i) {
        QString arg = QString::fromLocal8Bit(argv[i]);
        const Constants::CliOption* opt = findOption(arg);

        if (!opt) {
            // 未知の引数はプログラムID候補として扱う
            if (!arg.startsWith("-")) {
                opts.programIds.push_back(arg);
            }
            continue;
        }

        // -nogui は main の分岐にも使うので特別扱い
        if (opt->keyOption == Constants::KEY_NOGUI) {
            opts.nogui = true;
        }

        if (opt->requiresValue) {
            if (i + 1 < argc) {
                QString value = QString::fromLocal8Bit(argv[++i]);
                opts.optionValues[opt->keyOption] = value;
            }
        } else {
            opts.enabledFlags.insert(opt->keyOption);
        }
    }

    return opts;
}


#pragma once
#include <QString>
#include "settings.h"
#include "commandlineparser.h"
#include "runtimeconfig.h"

class CLIController
{
public:
    CLIController(const Settings& settings, int argc, char* argv[]);

    int run();

private:
    bool validateOptions(const CliOptions& opts) const;
    void applyCliOverrides(RuntimeConfig& config, const CliOptions& opts) const;

private:
    Settings m_settings;
    int m_argc;
    char** m_argv;
};

#include "clicontroller.h"
#include "recordingorchestrator.h"
#include <QDebug>

CLIController::CLIController(const Settings& settings, int argc, char* argv[])
    : m_settings(settings), m_argc(argc), m_argv(argv)
{
}

int CLIController::run()
{
    // ---- 1. 本格パース（抽象化済み） ----
    CliOptions opts = CommandLineParser::parse(m_argc, m_argv);

    // ---- 2. 妥当性確認（CommandLineParser では行わない） ----
    if (!validateOptions(opts)) {
        qWarning() << "CLI option validation failed.";
        return 1;
    }

    // ---- 3. Settings → RuntimeConfig へコピー ----
    RuntimeConfig config;
    config.applySettings(m_settings);

    // ---- 4. CLI オプションで RuntimeConfig を上書き ----
    applyCliOverrides(config, opts);

    // ---- 5. 実行プログラムへ制御移譲 ----
    RecordingOrchestrator orchestrator(&config);
    return orchestrator.runHeadless();
}

bool CLIController::validateOptions(const CliOptions& opts) const
{
    // 例：値を取るオプションの妥当性確認
    for (auto it = opts.optionValues.begin(); it != opts.optionValues.end(); ++it) {
        const char* key = it.key();
        const QString& value = it.value();

        if (value.isEmpty()) {
            qWarning() << "Empty value for option key:" << key;
            return false;
        }

        // 必要に応じて追加の妥当性チェックをここに書く
    }

    // 例：プログラムIDの妥当性確認（必要なら）
    // for (const QString& id : opts.programIds) { ... }

    return true;
}

void CLIController::applyCliOverrides(RuntimeConfig& config, const CliOptions& opts) const
{
    // ---- 値を取るオプション ----
    for (auto it = opts.optionValues.begin(); it != opts.optionValues.end(); ++it) {
        const char* key = it.key();
        const QString& value = it.value();
        config.setValue(key, value);   // RuntimeConfig が文字列キーを受け取る前提
    }

    // ---- フラグ（bool） ----
    for (const char* key : opts.enabledFlags) {
        config.setValue(key, true);
    }

    // ---- プログラムID（必要なら） ----
    if (!opts.programIds.empty()) {
        // 例：RuntimeConfig にセットする
        // config.setProgramIds(opts.programIds);
    }
}







#pragma once
#include <QString>
#include <QMap>
#include <QSet>
#include <vector>

struct SimpleCliOptions {
    bool nogui = false;
};

struct CliOptions {
    bool nogui = false;

    // 値を取るオプション
    QMap<int, QString> optionValues;

    // 値を取らないフラグ
    QSet<int> enabledFlags;

    // プログラムID候補
    std::vector<QString> programIds;
};

class CommandLineParser {
public:
    static SimpleCliOptions parseSimple(int argc, char* argv[]);
    static CliOptions parse(int argc, char* argv[]);
};


cpp
#include "commandlineparser.h"
#include "constants.h"

SimpleCliOptions CommandLineParser::parseSimple(int argc, char* argv[])
{
    SimpleCliOptions opts;

    for (int i = 1; i < argc; ++i) {
        QString arg = QString::fromLocal8Bit(argv[i]);
        if (arg == "-nogui" || arg == "--nogui") {
            opts.nogui = true;
        }
    }
    return opts;
}

CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    auto findOption = [&](const QString& arg) -> const Constants::CliOption* {
        for (int i = 0; i < Constants::getOptionTableCount(); ++i) {
            if (arg == Constants::OPTION_TABLE[i].optionStr)
                return &Constants::OPTION_TABLE[i];
        }
        return nullptr;
    };

    for (int i = 1; i < argc; ++i) {
        QString arg = QString::fromLocal8Bit(argv[i]);
        const Constants::CliOption* opt = findOption(arg);

        if (!opt) {
            if (!arg.startsWith("-")) {
                opts.programIds.push_back(arg);
            }
            continue;
        }

        // -nogui は main の分岐用にも使うので特別扱い
        if (opt->key == Constants::KEY_NOGUI) {
            opts.nogui = true;
        }

        if (opt->hasValue) {
            if (i + 1 < argc) {
                QString value = QString::fromLocal8Bit(argv[++i]);
                opts.optionValues[opt->key] = value;
            }
        } else {
            opts.enabledFlags.insert(opt->key);
        }
    }

    return opts;
}


main
SimpleCliOptions simple = CommandLineParser::parseSimple(argc, argv);

if (simple.nogui) {
    CLIController cli(settings, argc, argv);
    return cli.run();
}











// --- commandlineparser.h 等 ---
struct CliOptions {
    bool nogui = false;
    QStringList programIds;
    
    // 値を持たないフラグ系 (KEY_LAST_WEEK など)
    QSet<int> enabledFlags; 
    
    // 値を持つオプション系 (KEY_SaveFolder とそのパス文字列など)
    QMap<int, QString> optionValues; 
};



CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    auto findOption = [&](const QString& arg) -> const Constants::CliOption* {
        for (int i = 0; i < Constants::getOptionTableCount(); ++i) {
            if (arg == Constants::OPTION_TABLE[i].optionStr) // optionStrと照合
                return &Constants::OPTION_TABLE[i];
        }
        return nullptr;
    };

    for (int i = 1; i < argc; ++i) {
        QString arg = QString::fromLocal8Bit(argv[i]);
        const Constants::CliOption* opt = findOption(arg);

        if (!opt) {
            if (!arg.startsWith("-")) {
                opts.programIds.push_back(arg);
            }
            continue;
        }

        // 特別なフラグ "-nogui" だけは、mainでの分岐用に個別保持しても良い
        if (opt->keyOption == Constants::KEY_NOGUI) {
            opts.nogui = true;
        }

        if (opt->hasValue) { // Constants::CliOption の定義に基づく
            if (i + 1 < argc) {
                QString value = QString::fromLocal8Bit(argv[++i]);
                // マップに格納（キーと値をセットで保持）
                opts.optionValues[opt->keyOption] = value;
            }
        } else {
            // セットに格納（どのキーが有効になったかだけ保持）
            opts.enabledFlags.insert(opt->keyOption);
        }
    }
    return opts;
}



CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    auto findOption = [&](const QString& arg) -> const Constants::CliOption* {
        for (int i = 0; i < Constants::getOptionTableCount(); ++i) {
            if (arg == Constants::OPTION_TABLE[i].name)
                return &Constants::OPTION_TABLE[i];
        }
        return nullptr;
    };

    for (int i = 1; i < argc; ++i) {
        QString arg = QString::fromLocal8Bit(argv[i]);
        const Constants::CliOption* opt = findOption(arg);

        if (!opt) {
            // 未知の引数は一旦すべて ID候補として格納（妥当性確認は後続へ委ねる）
            opts.programIds.push_back(arg);
            continue;
        }

        opts.enabledKeys.push_back(opt->keyOption);

        if (opt->requiresValue) {
            if (i + 1 < argc) {
                QString value = QString::fromLocal8Bit(argv[++i]);
                // キーに基づいて値を格納
                switch (opt->keyOption) {
                    case Constants::KEY_CUSTOMIZED_TITLE1:  opts.titleTagFormat = value; break;
                    case Constants::KEY_CUSTOMIZED_FILENAME1: opts.fileNameFormat = value; break;
                    case Constants::KEY_SaveFolder:         opts.outputFolder   = value; break;
                    case Constants::KEY_AudioExtension:     opts.extension      = value; break;
                    default: break;
                }
            }
        } else {
            // フラグを単純にONにする
            if (opt->keyOption == Constants::KEY_NOGUI)           opts.nogui = true;
            else if (opt->keyOption == Constants::KEY_LAST_WEEK)  opts.optionZ = true;
            else if (opt->keyOption == Constants::KEY_BOTH_WEEKS) opts.optionB = true;
            else if (opt->keyOption == Constants::KEY_KOZA_SEPARATION) opts.optionS = true;
        }
    }
    return opts;
}


int CLIController::run(const CliOptions& rawOpts)
{
    // 1. 基本的なバリデーション（番組ID形式のチェック等）
    QStringList validIds;
    for (const QString& id : rawOpts.programIds) {
        if (isValidProgramId(id)) { // 別途定義したID形式チェック関数
            validIds << id;
        }
    }

    // 2. 仕様の適用：番組IDの有無による分岐
    if (validIds.isEmpty()) {
        // 【仕様】番組IDがない場合は -z, -b 以外無視
        // settings はロード済みのGUI設定を使用し、z/bフラグだけ適用する
        qDebug() << "CLI: No valid IDs. Recording GUI-selected programs.";
        executeRecording(this->settings, rawOpts.optionZ, rawOpts.optionB, false);
    } 
    else {
        // 【仕様】番組IDがある場合はオプションを上書き適用
        Settings runSettings = this->settings; // ベース設定をコピー
        
        if (!rawOpts.titleTagFormat.isEmpty()) runSettings.setTitleFormat(rawOpts.titleTagFormat);
        if (!rawOpts.outputFolder.isEmpty())   runSettings.setOutputDir(rawOpts.outputFolder);
        // ... (以下、他のオプションも同様に上書き)
        
        qDebug() << "CLI: Recording target IDs:" << validIds;
        executeRecordingForIds(validIds, runSettings, rawOpts.optionZ, rawOpts.optionB, rawOpts.optionS);
    }

    return 0;
}






#include <QApplication>
#include <QCoreApplication>
#include "mainwindow.h"
#include "clicontroller.h"
#include "utility.h"
#include "settings.h"

int main(int argc, char* argv[]) {
    // 1. 設定のロード（共通）
    Settings settings;
    settings.load();

    // 2. GUIなし（CLI）モードの判定
    // SimpleCliOptions や Utility::nogui() を使用
    if (Utility::checkNoGuiFlag(argc, argv)) {
        // --- CLIモードのスコープ ---
        QCoreApplication app(argc, argv); // GUI機能を除いた軽量版
        
        CLIController cli(settings, argc, argv);
        // ロックチェックは行わず、そのまま実行
        return cli.run(); 
    }

    // --- GUIモードのスコープ ---
    // 高DPI設定などは QApplication 生成前に
    qputenv("QT_AUTO_SCREEN_SCALE_FACTOR", "1");

    QApplication app(argc, argv);

    // 3. GUIのみ二重起動防止を適用
    if (!Utility::tryLockFile()) {
        // すでに起動している旨を通知（GUIならダイアログを出しても良い）
        return 1; 
    }

    // 4. ウィンドウ生成と表示
    MainWindow w(settings);
    QGuiApplication::setWindowIcon(QIcon(":icon.png"));
    w.show();

    // 5. メインループ開始
    int result = app.exec();

    // 6. 終了時にロック解除
    Utility::unLockFile();

    return result;
}




SimpleCliOptions CommandLineParser::parseSimple(int argc, char* argv[])
{
    SimpleCliOptions opts;

    for (int i = 1; i < argc; ++i) {
        QString arg = argv[i];
        if (arg == "-nogui" || arg == "--nogui") {
            opts.nogui = true;
        }
    }

    return opts;
}

int main(int argc, char* argv[]) {
    Settings settings;
    settings.load();

    // ---- 簡易パーサーで nogui だけ判定 ----
    SimpleCliOptions simple = CommandLineParser::parseSimple(argc, argv);

    if (simple.nogui) {
        CLIController cli(settings, argc, argv);
        return cli.run();
    }

    QApplication app(argc, argv);
    MainWindow w(settings);
    w.show();
    return app.exec();
}








// tryLockFile の改善
bool Utility::tryLockFile() {
    // 複数起動が許可されているなら、ロックせずに通す
    if (multi_gui_flag_check()) {
        return true;
    }

    // 0.1秒は短すぎるので、30秒（30000ms）程度に
    lockFile.setStaleLockTime(30000); 

    // もし古いロックファイルが残っていたら掃除する
    // (これを tryLock の前に呼ぶのが一般的)
    lockFile.removeStaleLockFile();

    return lockFile.tryLock();
}

// 2つの解除関数を1つに統合してスッキリさせる
void Utility::releaseLock() {
    if (lockFile.isLocked()) {
        lockFile.unlock();
    }
}

int main(int argc, char *argv[]) {
    // 1. 環境設定（QApplicationの前）
    qputenv("QT_AUTO_SCREEN_SCALE_FACTOR", "1");

    QApplication a(argc, argv);

    // 2. 二重起動チェック（MainWindowを作る前に！）
    // ここで失敗したら即終了
    if (!Utility::tryLockFile()) {
        return 0; 
    }

    // 3. GUI構築
    MainWindow w;
    QGuiApplication::setWindowIcon(QIcon(":icon.png"));

    // 4. 実行
    if (Utility::nogui()) {
        w.download();
    } else {
        w.show();
    }

    int result = a.exec();

    // 5. 終了時にロック解除
    Utility::releaseLock();

    return result;
}





SimpleCliOptions CommandLineParser::parseSimple(int argc, char* argv[])
{
    SimpleCliOptions opts;

    for (int i = 1; i < argc; ++i) {
        QString arg = argv[i];
        if (arg == "-nogui" || arg == "--nogui") {
            opts.nogui = true;
        }
    }

    return opts;
}




struct CommandLineOptions {
    bool noGui = false;
};

CommandLineOptions parseCommandLine(int argc, char* argv[]) {
    CommandLineOptions opts;

    for (int i = 1; i < argc; ++i) {
        QString arg = argv[i];

        if (arg == "-nogui" || arg == "--nogui") {
            opts.noGui = true;
        }
        // 必要になればここに追加（--record, --input など）
    }

    return opts;
}

class CLIController {
public:
    CLIController(RecordingOrchestrator* orchestrator)
        : m_orchestrator(orchestrator) {}

    int run() {
        // ここで CLI の実行ロジックを書く
        // 例: 録画開始 → 停止 → 終了
        auto sessionId = m_orchestrator->startRecording();
        if (!sessionId) {
            qWarning() << "Failed to start recording";
            return 1;
        }

        qInfo() << "Recording started. Press Ctrl+C to stop.";

        // シンプルに待つだけ（本番はシグナルハンドラなど）
        QThread::sleep(5);

        m_orchestrator->stopRecording(*sessionId);
        qInfo() << "Recording stopped.";

        return 0;
    }

private:
    RecordingOrchestrator* m_orchestrator;
};







RuntimeConfig::RuntimeConfig()
{
    // --- フラグ・チェックボックス系 ---
    // ここで resize しないと applySettings などで落ちます
    checkBox.resize(Constants::getFeatureCount());

    // --- 番組データ系 ---
    english.resize(Constants::getEnglishCount());
    optional.resize(Constants::getOptionalCount());
    spec.resize(Constants::getSpecCount());

    // --- カスタマイズ形式系 ---
    titleFormat.resize(Constants::getItemCount());
    fileNameFormat.resize(Constants::getItemCount());

    // --- フラグの初期値を Constants::FlagTable から読み込む ---
    for (int i = 0; i < Constants::getFlagCount(); ++i) {
        const auto& entry = Constants::FlagTable[i];
        flags[entry.keyFlag] = entry.flagDefault;
    }
}




#pragma once
#include "constants_core.h"

namespace Constants {

struct CliOption {
    const char* name;
    bool requiresValue;
    const char* keyOption; // GUI、Flagの キーと一致
    const char* description;
};

// --- 外部参照の宣言 ---
extern const CliOption OPTION_TABLE[];

// --- 個数取得関数の宣言 ---
int getOptionTableCount();

} // namespace Constants


#include "constants_cli.h"

namespace Constants {

/* ============================================================
 * CLI オプションテーブル
 * ========================================================== */
const CliOption OPTION_TABLE[] = {
    { "-nogui", false, KEY_NOGUI,              "GUI を起動せずに実行します" },
    { "-t",     true,  KEY_CUSTOMIZED_TITLE1,  "タイトルタグ形式を指定します" },
    { "-f",     true,  KEY_CUSTOMIZED_FILENAME1,"ファイル名形式を指定します" },
    { "-o",     true,  KEY_SaveFolder,         "保存フォルダのフルパスを指定します" },
    { "-e",     true,  KEY_AudioExtension,     "拡張子を指定します" },
    { "-z",     false, KEY_LAST_WEEK,          "前週の動作を行います" },
    { "-b",     false, KEY_BOTH_WEEKS,         "前週と当週の両方を実行します" },
    { "-s",     false, KEY_KOZA_SEPARATION,    "応用編分離を有効にします" },
};

// --- 個数取得の実装 ---
int getOptionTableCount() {
    return sizeof(OPTION_TABLE) / sizeof(OPTION_TABLE[0]);
}

} // namespace Constants




RuntimeConfig::RuntimeConfig()
{
    // ここで Constants から個数を取得して resize する
    checkBox.resize(Constants::getFeatureCount());
    
    // もし FlagTable 用の配列もあるなら同様に
    // flags.resize(Constants::getFlagCount());
}




// 修正前
const int EnglishCount = sizeof(EnglishPrograms) / sizeof(EnglishPrograms[0]);

// 修正後（関数の実装だけでOK。関数内で sizeof を使う）
int getEnglishCount() {
    return sizeof(EnglishPrograms) / sizeof(EnglishPrograms[0]);
}

// ... (前半の配列定義などはそのまま) ...

// ===== カウント関数の実装 =====
int getEnglishCount()  { return sizeof(EnglishPrograms) / sizeof(EnglishPrograms[0]); }
int getOptionalCount() { return sizeof(OptionalPrograms) / sizeof(OptionalPrograms[0]); }
int getSpecCount()     { return sizeof(SpecPrograms) / sizeof(SpecPrograms[0]); }
int getItemCount()     { return sizeof(FILENAME_ITEMS) / sizeof(FILENAME_ITEMS[0]); }

// getPresetsCount なども必要であれば追加
int getOptPresetSize() { return static_cast<int>(getOptPresets().size()); }
int getPresetSize()    { return static_cast<int>(getPresets().size()); }

// プリセット等の個数も sizeof で
int getFilenamePresetCount() { return sizeof(FILENAME_PRESETS) / sizeof(FILENAME_PRESETS[0]); }
int getTitlePresetCount()    { return sizeof(TITLE_PRESETS) / sizeof(TITLE_PRESETS[0]); }

} // namespace Constants





#include "constants_flags.h"

namespace Constants {

/* ============================================================
 * Feature（チェックボックス）
 * ------------------------------------------------------------
 * ini に保存される、UIと連動する設定。
 * ========================================================== */
const ProgramDefinition FeatureSettings[] = {
    { ProgramDefinition::Kind::Feature, "skip", true, nullptr, nullptr, false, false, "skip_keyLabel", "既存のファイルはスキップ", false, true, "toolButton_skip" },
    { ProgramDefinition::Kind::Feature, "this_week", true, nullptr, nullptr, false, false, nullptr, nullptr, false, false, "checkBox_this_week" },
    { ProgramDefinition::Kind::Feature, "thumbnail", false, nullptr, nullptr, false, false, nullptr, nullptr, false, false, "checkBox_thumbnail" },
    { ProgramDefinition::Kind::Feature, "koza_separation", true, nullptr, nullptr, false, false, nullptr, nullptr, false, false, "checkBox_koza_separation" },
    { ProgramDefinition::Kind::Feature, "multi_gui", false, nullptr, nullptr, false, false, nullptr, nullptr, false, false, "checkBox_multi_gui" },
    { ProgramDefinition::Kind::Feature, "name_space", true, nullptr, nullptr, false, false, nullptr, nullptr, false, false, "checkBox" },
    { ProgramDefinition::Kind::Feature, "tag_space", true, nullptr, nullptr, false, false, nullptr, nullptr, false, false, "checkBox" },
    { ProgramDefinition::Kind::Feature, "detailed_message", false, nullptr, nullptr, false, false, nullptr, nullptr, false, false, "toolButton_detailed_message" }
};

// --- 個数取得 ---
int getFeatureCount() {
    return sizeof(FeatureSettings) / sizeof(FeatureSettings[0]);
}

/* ============================================================
 * Flag（実行時フラグ）
 * ------------------------------------------------------------
 * RuntimeConfig で使用される、保存されないフラグ。
 * ========================================================== */   
const FlagEntry FlagTable[] = {
    { KEY_NOGUI,        false },
    { KEY_LAST_WEEK,    false },
    { KEY_BOTH_WEEKS,   false },
    { KEY_PROGRAM_LIST, false },
    { "featureX",       true  }
};

// --- 個数取得 ---
int getFlagCount() {
    return sizeof(FlagTable) / sizeof(FlagTable[0]);
}

} // namespace Constants




[  9%] Building CXX object CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:41,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:60:30: error: conversion from ‘int (*)()’ to ‘long unsigned int’ in a converted constant expression
   60 |     bool checkBox[Constants::getFeatureCount];
      |                   ~~~~~~~~~~~^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:60:30: error: could not convert ‘Constants::getFeatureCount’ from ‘int()’ to ‘long unsigned int’
   60 |     bool checkBox[Constants::getFeatureCount];
      |                   ~~~~~~~~~~~^~~~~~~~~~~~~~~
      |                              |
      |                              int()
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:60:30: error: size of array ‘checkBox’ has non-integral type ‘int()’
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:85: CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2







#include "constants_flags.h"

namespace Constants {

/* ============================================================
 * Feature（チェックボックス）
 * ========================================================== */
const ProgramDefinition FeatureSettings[] = {
    { ProgramDefinition::Kind::Feature,
      "skip", true,
      nullptr, nullptr, false, false,
      "skip_keyLabel", "既存のファイルはスキップ", false, true,
      "toolButton_skip" },

    { ProgramDefinition::Kind::Feature,
      "this_week", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_this_week" },

    { ProgramDefinition::Kind::Feature,
      "thumbnail", false,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_thumbnail" },

    { ProgramDefinition::Kind::Feature,
      "koza_separation", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_koza_separation" },

    { ProgramDefinition::Kind::Feature,
      "multi_gui", false,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_multi_gui" },

    { ProgramDefinition::Kind::Feature,
      "name_space", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox" },

    { ProgramDefinition::Kind::Feature,
      "tag_space", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox" },

    { ProgramDefinition::Kind::Feature,
      "detailed_message", false,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "toolButton_detailed_message" }
};

// 個数取得の実装
int getFeatureCount() {
    return sizeof(FeatureSettings) / sizeof(FeatureSettings[0]);
}

/* ============================================================
 * Flag（チェックボックス、CLIオプションなど）
 * ========================================================== */   
const FlagEntry FlagTable[] = {
    { KEY_NOGUI,        false },
    { KEY_LAST_WEEK,    false },
    { KEY_BOTH_WEEKS,   false },
    { KEY_PROGRAM_LIST, false },
    { "featureX",       true  }
};

// 個数取得の実装
int getFlagCount() {
    return sizeof(FlagTable) / sizeof(FlagTable[0]);
}

}

#include "constants_flags.h"

namespace Constants {

/* ============================================================
 * Feature（チェックボックス）
 * ========================================================== */
const ProgramDefinition FeatureSettings[] = {
    { ProgramDefinition::Kind::Feature,
      "skip", true,
      nullptr, nullptr, false, false,
      "skip_keyLabel", "既存のファイルはスキップ", false, true,
      "toolButton_skip" },

    { ProgramDefinition::Kind::Feature,
      "this_week", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_this_week" },

    { ProgramDefinition::Kind::Feature,
      "thumbnail", false,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_thumbnail" },

    { ProgramDefinition::Kind::Feature,
      "koza_separation", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_koza_separation" },

    { ProgramDefinition::Kind::Feature,
      "multi_gui", false,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox_multi_gui" },

    { ProgramDefinition::Kind::Feature,
      "name_space", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox" },

    { ProgramDefinition::Kind::Feature,
      "tag_space", true,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "checkBox" },

    { ProgramDefinition::Kind::Feature,
      "detailed_message", false,
      nullptr, nullptr, false, false,
      nullptr, nullptr, false, false,
      "toolButton_detailed_message" }
};

// 個数取得の実装
int getFeatureCount() {
    return sizeof(FeatureSettings) / sizeof(FeatureSettings[0]);
}

/* ============================================================
 * Flag（チェックボックス、CLIオプションなど）
 * ========================================================== */   
const FlagEntry FlagTable[] = {
    { KEY_NOGUI,        false },
    { KEY_LAST_WEEK,    false },
    { KEY_BOTH_WEEKS,   false },
    { KEY_PROGRAM_LIST, false },
    { "featureX",       true  }
};

// 個数取得の実装
int getFlagCount() {
    return sizeof(FlagTable) / sizeof(FlagTable[0]);
}

}






Settings::Settings()
{
    // ここでサイズを確保しないと、load() で [i] アクセスした時に落ちます
    optionals.resize(Constants::getOptionalCount());
    specials.resize(Constants::getSpecCount());
    titleFormat.resize(Constants::getItemCount());
    fileNameFormat.resize(Constants::getItemCount());
}



namespace Constants {

// 配列そのものを関数の中に隠す（これが最も安全）
const ProgramDefinition* getEnglishPrograms() {
    static const ProgramDefinition instance[] = {
        { ... }, { ... }
    };
    return instance;
}

// カウントもこの関数内の配列から計算するようにする
int getEnglishCount() {
    // getEnglishPrograms() 内の配列サイズを安全に取るために工夫が必要
    // もしくは、ここに直接 static 配列を置く
    static const ProgramDefinition instance[] = { { ... }, { ... } };
    return sizeof(instance) / sizeof(instance[0]);
}

}




Segmentation fault (コアダンプ)



void Settings::load() {
    // ... 前後の処理 ...

    // English
    for (int i = 0; i < Constants::getEnglishCount(); ++i) {
        loadProgramDefinition(Constants::EnglishPrograms[i], ini);
    }

    // Optional
    for (int i = 0; i < Constants::getOptionalCount(); ++i) {
        loadProgramDefinition(Constants::OptionalPrograms[i], ini);
    }

    // Spec
    for (int i = 0; i < Constants::getSpecCount(); ++i) {
        loadProgramDefinition(Constants::SpecPrograms[i], ini);
    }
    
    // ...
}


void Settings::save() {
    // ... 前後の処理 ...

    // English
    for (int i = 0; i < Constants::getEnglishCount(); ++i) {
        saveProgramDefinition(Constants::EnglishPrograms[i], ini);
    }

    // Optional
    for (int i = 0; i < Constants::getOptionalCount(); ++i) {
        saveProgramDefinition(Constants::OptionalPrograms[i], ini);
    }

    // Spec
    for (int i = 0; i < Constants::getSpecCount(); ++i) {
        saveProgramDefinition(Constants::SpecPrograms[i], ini);
    }

    // ...
}







[  9%] Building CXX object CMakeFiles/CaptureStream2.dir/settings.cpp.o
/home/kazuo/cs/CaptureStream2/settings.cpp: In member function ‘void Settings::load()’:
/home/kazuo/cs/CaptureStream2/settings.cpp:49:37: error: range-based ‘for’ expression of type ‘const Constants::ProgramDefinition []’ has incomplete type
   49 |     for (const auto &p : Constants::EnglishPrograms) loadProgramDefinition(p, ini);
      |                                     ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/settings.cpp:50:37: error: range-based ‘for’ expression of type ‘const Constants::ProgramDefinition []’ has incomplete type
   50 |     for (const auto &p : Constants::OptionalPrograms) loadProgramDefinition(p, ini);
      |                                     ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/settings.cpp:51:37: error: range-based ‘for’ expression of type ‘const Constants::ProgramDefinition []’ has incomplete type
   51 |     for (const auto &p : Constants::SpecPrograms)     loadProgramDefinition(p, ini);
      |                                     ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/settings.cpp: In member function ‘void Settings::save()’:
/home/kazuo/cs/CaptureStream2/settings.cpp:124:37: error: range-based ‘for’ expression of type ‘const Constants::ProgramDefinition []’ has incomplete type
  124 |     for (const auto &p : Constants::EnglishPrograms) saveProgramDefinition(p, ini);
      |                                     ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/settings.cpp:125:37: error: range-based ‘for’ expression of type ‘const Constants::ProgramDefinition []’ has incomplete type
  125 |     for (const auto &p : Constants::OptionalPrograms) saveProgramDefinition(p, ini);
      |                                     ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/settings.cpp:126:37: error: range-based ‘for’ expression of type ‘const Constants::ProgramDefinition []’ has incomplete type
  126 |     for (const auto &p : Constants::SpecPrograms)     saveProgramDefinition(p, ini);
      |                                     ^~~~~~~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:253: CMakeFiles/CaptureStream2.dir/settings.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2





void ScrambleDialog::updateLabels() {
    // std::array をやめて QVector にする
    QVector<QLabel*> labels = {
        ui.label_optional1, ui.label_optional2, ui.label_optional3, ui.label_optional4,
        ui.label_optional5, ui.label_optional6, ui.label_optional7, ui.label_optional8
    };

    // labels.size() を使えば安全にループできます
    for (int i = 0; i < labels.size() && i < Constants::getOptionalCount(); ++i) {
        // ... ラベル更新処理 ...
    }
}

void ScrambleDialog::updateLabels() {
    // 初期化子リストを直接使ってループを回す
    const auto labels = {
        ui.label_optional1, ui.label_optional2, ui.label_optional3, ui.label_optional4,
        ui.label_optional5, ui.label_optional6, ui.label_optional7, ui.label_optional8
    };

    int i = 0;
    for (QLabel* label : labels) {
        if (i >= Constants::getOptionalCount()) break;
        // label->setText(...) 等の処理
        i++;
    }
}





void ScrambleDialog::someMethod() {
    const auto& OPT_PRESETS = Constants::getOptPresets(); // ここで名前を定義
    
    // これ以降は以前と同じコード（OPT_PRESETS.size()など）がそのまま動く
    for (int j = 0; j < OPT_PRESETS.size(); ++j) { ... }
}



    // チェックされているプリセットを適用
    for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = OPT_PRESETS[j][index];
        }
    }

    // プリセット適用
    for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = OPT_PRESETS[j][index];
        }
    }


元々
constants_programs.h
inline const QVector<QStringList> OPT_PRESETS = {

としていたところを下記のようにへんこうしたので
constants_programs.cpp
const QVector<QStringList>& getOptPresets() {
    static const QVector<QStringList> instance = {
下記エラーとなった
   72 |     for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {

[  9%] Building CXX object CMakeFiles/CaptureStream2.dir/scrambledialog.cpp.o
/home/kazuo/cs/CaptureStream2/scrambledialog.cpp: In member function ‘QString ScrambleDialog::scramble_set(QString, int)’:
/home/kazuo/cs/CaptureStream2/scrambledialog.cpp:72:25: error: ‘OPT_PRESETS’ was not declared in this scope
   72 |     for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {
      |                         ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/scrambledialog.cpp: In member function ‘void ScrambleDialog::updateLabels()’:
/home/kazuo/cs/CaptureStream2/scrambledialog.cpp:112:52: error: call to non-‘constexpr’ function ‘int Constants::getOptionalCount()’
  112 |     std::array<QLabel*, Constants::getOptionalCount()> labels = {
      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~
In file included from /home/kazuo/cs/CaptureStream2/constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/settings.h:30,
                 from /home/kazuo/cs/CaptureStream2/scrambledialog.h:28,
                 from /home/kazuo/cs/CaptureStream2/scrambledialog.cpp:24:
/home/kazuo/cs/CaptureStream2/constants_programs.h:71:9: note: ‘int Constants::getOptionalCount()’ declared here
   71 |     int getOptionalCount();
      |         ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/scrambledialog.cpp:112:52: error: call to non-‘constexpr’ function ‘int Constants::getOptionalCount()’
  112 |     std::array<QLabel*, Constants::getOptionalCount()> labels = {
      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~
In file included from /home/kazuo/cs/CaptureStream2/constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/settings.h:30,
                 from /home/kazuo/cs/CaptureStream2/scrambledialog.h:28,
                 from /home/kazuo/cs/CaptureStream2/scrambledialog.cpp:24:
/home/kazuo/cs/CaptureStream2/constants_programs.h:71:9: note: ‘int Constants::getOptionalCount()’ declared here
   71 |     int getOptionalCount();
      |         ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/scrambledialog.cpp:112:52: note: in template argument for type ‘long unsigned int’
  112 |     std::array<QLabel*, Constants::getOptionalCount()> labels = {
      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~
/home/kazuo/cs/CaptureStream2/scrambledialog.cpp:112:56: error: scalar object ‘labels’ requires one element in initializer
  112 |     std::array<QLabel*, Constants::getOptionalCount()> labels = {
      |                                                        ^~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:197: CMakeFiles/CaptureStream2.dir/scrambledialog.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2



const Constants::ProgramDefinition* MainWindow::findEntryByObjectName(const QString& obj) const
{
    // 引数を「配列の先頭ポインタ」と「個数」に変更する
    auto search = [&](const Constants::ProgramDefinition* list, int count) -> const Constants::ProgramDefinition* {
        for (int i = 0; i < count; ++i) {
            const auto& p = list[i];
            if (QString(p.objectName) == obj)
                return &p;
        }
        return nullptr;
    };

    // 呼び出し時に Constants から取得した個数を渡す
    if (auto* p = search(Constants::EnglishPrograms, Constants::getEnglishCount()))  return p;
    if (auto* p = search(Constants::OptionalPrograms, Constants::getOptionalCount())) return p;
    if (auto* p = search(Constants::SpecPrograms, Constants::getSpecCount()))     return p;
    
    // FeatureSettings も同様に関数化されている前提です
    if (auto* p = search(Constants::FeatureSettings, Constants::getFeatureCount()))  return p;
    
    return nullptr;
}




[ 28%] Building CXX object CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o
/home/kazuo/cs/CaptureStream2/mainwindow.cpp: In instantiation of ‘MainWindow::findEntryByObjectName(const QString&) const::<lambda(const auto:34&)> [with auto:34 = Constants::ProgramDefinition []]’:
/home/kazuo/cs/CaptureStream2/mainwindow.cpp:1377:25:   required from here
/home/kazuo/cs/CaptureStream2/mainwindow.cpp:1370:9: error: range-based ‘for’ expression of type ‘const Constants::ProgramDefinition []’ has incomplete type
 1370 |         for (const auto& p : list) {
      |         ^~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:169: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2


下記の部分どう直せばよいですか？
const Constants::ProgramDefinition* MainWindow::findEntryByObjectName(const QString& obj) const
{
    auto search = [&](const auto& list) -> const Constants::ProgramDefinition* {
        for (const auto& p : list) {
            if (p.objectName == obj)
                return &p;
        }
        return nullptr;
    };

    if (auto* p = search(Constants::EnglishPrograms))  return p;
    if (auto* p = search(Constants::OptionalPrograms)) return p;
    if (auto* p = search(Constants::SpecPrograms))     return p;
    if (auto* p = search(Constants::FeatureSettings))  return p;
    
    return nullptr;
}




// customizedialog.h

class CustomizeDialog : public QDialog
{
    Q_OBJECT

public:
    // ... 既存の定義 ...

private:
    Ui::CustomizeDialog ui; // クラス名に合わせて適宜
    Ui::DialogMode mode;

    // --- ここに追加 ---
    // Constants から移動し、このクラス専用の定数にする
    static inline const QStringList COURSES = {
        QStringLiteral("json"),
        QStringLiteral("xml")
    };
    // ----------------

    void loadSettings();
    void saveSettings();
    void applyPreset(int index);
};


/* ============================================================
 * formats()
 * course → settings.ini から titleFormat / fileNameFormat を取得
 * ============================================================ */
void CustomizeDialog::formats(QString course, QString& titleFormat, QString& fileNameFormat)
{
    // Constants::COURSES から COURSES (自クラスの定数) に変更
    int index = COURSES.indexOf(course);
    if (index < 0)
        index = 0;

    titleFormat    = Settings::getTitleFormat(index);
    fileNameFormat = Settings::getFileNameFormat(index);
}






エラーメッセージ
[ 14%] Building CXX object CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o
/home/kazuo/cs/CaptureStream2/customizedialog.cpp: In static member function ‘static void CustomizeDialog::formats(QString, QString&, QString&)’:
/home/kazuo/cs/CaptureStream2/customizedialog.cpp:61:28: error: ‘COURSES’ is not a member of ‘Constants’
   61 |     int index = Constants::COURSES.indexOf(course);
      |                            ^~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:113: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2

現在constantsに外出ししている
    inline const QStringList COURSES = {
        QStringLiteral("json"),
        QStringLiteral("xml")
    };
の部分はcustomizedialog内でしか使っていないので、customizedialog側に戻したほうが良いと思うが、どうすればよいですか
下記sのcustomizedialogの修正箇所を教えてください


#include "customizedialog.h"
#include "settings.h"
#include "constants.h"
#include "mainwindow.h"

CustomizeDialog::CustomizeDialog(Ui::DialogMode mode, QWidget *parent)
    : QDialog(parent), mode(mode)
{
    ui.setupUi(this);

    setWindowTitle(mode == Ui::TitleMode
                   ? QStringLiteral("タイトルタグ設定")
                   : QStringLiteral("ファイル名設定"));

    loadSettings();

    // ラジオボタン → プリセット適用
    connect(ui.radioButton, &QRadioButton::clicked, this, [this](){ applyPreset(0); });
    connect(ui.radioButton_1, &QRadioButton::clicked, this, [this](){ applyPreset(1); });
    connect(ui.radioButton_2, &QRadioButton::clicked, this, [this](){ applyPreset(2); });
    connect(ui.radioButton_3, &QRadioButton::clicked, this, [this](){ applyPreset(3); });
    connect(ui.radioButton_4, &QRadioButton::clicked, this, [this](){ applyPreset(4); });
    connect(ui.radioButton_5, &QRadioButton::clicked, this, [this](){ applyPreset(5); });
    connect(ui.radioButton_6, &QRadioButton::clicked, this, [this](){ applyPreset(6); });

    connect(this, SIGNAL(accepted()), this, SLOT(accepted()));
    
    ui.radioButton_9->setChecked(true);
    ui.radioButton_19->setChecked(true);
}

/* ============================================================
 *  formats()
 *  course → settings.ini から titleFormat / fileNameFormat を取得
 * ============================================================ */
void CustomizeDialog::formats(QString course, QString& titleFormat, QString& fileNameFormat)
{
    int index = Constants::COURSES.indexOf(course);
    if (index < 0)
        index = 0;

    titleFormat    = Settings::getTitleFormat(index);
    fileNameFormat = Settings::getFileNameFormat(index);
}

/* ============================================================
 *  設定読み込み
 * ============================================================ */
void CustomizeDialog::loadSettings()
{
    ui.lineEdit->setText(
        mode == Ui::TitleMode
            ? Settings::getTitleFormat(0)
            : Settings::getFileNameFormat(0)
    );

    ui.lineEdit_2->setText(
        mode == Ui::TitleMode
            ? Settings::getTitleFormat(1)
            : Settings::getFileNameFormat(1)
    );

    if (mode == Ui::TitleMode)
        ui.checkBox->setChecked(Settings::tagSpaceFlag());
    else
        ui.checkBox->setChecked(Settings::nameSpaceFlag());
}

/* ============================================================
 *  設定保存
 * ============================================================ */
void CustomizeDialog::saveSettings()
{
    if (mode == Ui::TitleMode) {
        Settings::instance().setTitleFormatValue(0, ui.lineEdit->text());
        Settings::instance().setTitleFormatValue(1, ui.lineEdit_2->text());
        Settings::setTagSpaceFlag(ui.checkBox->isChecked());
    } else {
        Settings::instance().setFileNameFormatValue(0, ui.lineEdit->text());
        Settings::instance().setFileNameFormatValue(1, ui.lineEdit_2->text());
        Settings::setNameSpaceFlag(ui.checkBox->isChecked());
    }
}


/* ============================================================
 *  OK ボタン
 * ============================================================ */
void CustomizeDialog::accepted()
{
    saveSettings();
}

/* ============================================================
 *  プリセット適用（構造体ベース）
 * ============================================================ */
void CustomizeDialog::applyPreset(int index)
{
    if (mode == Ui::TitleMode) {
        ui.lineEdit->setText(Constants::TITLE_PRESETS[index].value);
    } else {
        ui.lineEdit->setText(Constants::FILENAME_PRESETS[index].value);
    }
}





// 修正前
// std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
// std::array<QString, Constants::PRESET_SIZE> specials;
// QString titleFormat[Constants::ITEM_COUNT];
// QString fileNameFormat[Constants::ITEM_COUNT];

// 修正後
#include <QVector>

// ... クラス定義内 ...
    QVector<QString> optionals;
    QVector<QString> specials;
    QVector<QString> titleFormat;
    QVector<QString> fileNameFormat;


Settings::Settings() {
    optionals.resize(Constants::getOptionalCount());
    specials.resize(Constants::getSpecCount());
    titleFormat.resize(Constants::getItemCount());
    fileNameFormat.resize(Constants::getItemCount());
}

// 修正前
// RuntimeProgram english[Constants::EnglishCount];
// RuntimeProgram optional[Constants::OptionalCount];
// RuntimeProgram spec[Constants::SpecCount];
// QString titleFormat[Constants::ITEM_COUNT];
// QString fileNameFormat[Constants::ITEM_COUNT];

// 修正後
    QVector<RuntimeProgram> english;
    QVector<RuntimeProgram> optional;
    QVector<RuntimeProgram> spec;
    QVector<QString> titleFormat;
    QVector<QString> fileNameFormat;


RuntimeConfig::RuntimeConfig() {
    english.resize(Constants::getEnglishCount());
    optional.resize(Constants::getOptionalCount());
    spec.resize(Constants::getSpecCount());
    titleFormat.resize(Constants::getItemCount());
    fileNameFormat.resize(Constants::getItemCount());
}

// 修正前: std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;
QVector<QLineEdit*> edits;

// 修正前: std::array<QLineEdit*, Constants::PRESET_SIZE> edits;
QVector<QLineEdit*> edits;


修正前: for (int i = 0; i < Constants::EnglishCount; ++i)
• 修正後: for (int i = 0; i < Constants::getEnglishCount(); ++i)
• または for (int i = 0; i < english.size(); ++i)










[  9%] Building CXX object CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:71:36: error: size of array ‘titleFormat’ is not an integral constant-expression
   71 |     QString titleFormat[Constants::ITEM_COUNT];
      |                         ~~~~~~~~~~~^~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:72:39: error: size of array ‘fileNameFormat’ is not an integral constant-expression
   72 |     QString fileNameFormat[Constants::ITEM_COUNT];
      |                            ~~~~~~~~~~~^~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:41,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:57:39: error: size of array ‘english’ is not an integral constant-expression
   57 |     RuntimeProgram english[Constants::EnglishCount];
      |                            ~~~~~~~~~~~^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:58:40: error: size of array ‘optional’ is not an integral constant-expression
   58 |     RuntimeProgram optional[Constants::OptionalCount];
      |                             ~~~~~~~~~~~^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:59:36: error: size of array ‘spec’ is not an integral constant-expression
   59 |     RuntimeProgram spec[Constants::SpecCount];
      |                         ~~~~~~~~~~~^~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:68:36: error: size of array ‘titleFormat’ is not an integral constant-expression
   68 |     QString titleFormat[Constants::ITEM_COUNT];
      |                         ~~~~~~~~~~~^~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:69:39: error: size of array ‘fileNameFormat’ is not an integral constant-expression
   69 |     QString fileNameFormat[Constants::ITEM_COUNT];
      |                            ~~~~~~~~~~~^~~~~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:85: CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2


[ 14%] Building CXX object CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:63:36: error: ‘OPT_PRESET_SIZE’ is not a member of ‘Constants’
   63 |     std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
      |                                    ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:63:51: error: template argument 2 is invalid
   63 |     std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
      |                                                   ^
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:64:36: error: ‘PRESET_SIZE’ is not a member of ‘Constants’
   64 |     std::array<QString, Constants::PRESET_SIZE> specials;
      |                                    ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:64:47: error: template argument 2 is invalid
   64 |     std::array<QString, Constants::PRESET_SIZE> specials;
      |                                               ^
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:71:36: error: size of array ‘titleFormat’ is not an integral constant-expression
   71 |     QString titleFormat[Constants::ITEM_COUNT];
      |                         ~~~~~~~~~~~^~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:72:39: error: size of array ‘fileNameFormat’ is not an integral constant-expression
   72 |     QString fileNameFormat[Constants::ITEM_COUNT];
      |                            ~~~~~~~~~~~^~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:41,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:57:39: error: size of array ‘english’ is not an integral constant-expression
   57 |     RuntimeProgram english[Constants::EnglishCount];
      |                            ~~~~~~~~~~~^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:58:40: error: size of array ‘optional’ is not an integral constant-expression
   58 |     RuntimeProgram optional[Constants::OptionalCount];
      |                             ~~~~~~~~~~~^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:59:36: error: size of array ‘spec’ is not an integral constant-expression
   59 |     RuntimeProgram spec[Constants::SpecCount];
      |                         ~~~~~~~~~~~^~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:68:36: error: size of array ‘titleFormat’ is not an integral constant-expression
   68 |     QString titleFormat[Constants::ITEM_COUNT];
      |                         ~~~~~~~~~~~^~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:69:39: error: size of array ‘fileNameFormat’ is not an integral constant-expression
   69 |     QString fileNameFormat[Constants::ITEM_COUNT];
      |                            ~~~~~~~~~~~^~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_scrambledialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:8:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../scrambledialog.h:53:39: error: ‘OPT_PRESET_SIZE’ is not a member of ‘Constants’
   53 |     std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;
      |                                       ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../scrambledialog.h:53:54: error: template argument 2 is invalid
   53 |     std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;
      |                                                      ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_settingsdialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:9:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settingsdialog.h:53:39: error: ‘PRESET_SIZE’ is not a member of ‘Constants’
   53 |     std::array<QLineEdit*, Constants::PRESET_SIZE> edits;
      |                                       ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settingsdialog.h:53:50: error: template argument 2 is invalid
   53 |     std::array<QLineEdit*, Constants::PRESET_SIZE> edits;
      |                                                  ^
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:85: CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2





QString folder = runtime.saveFolder;
QString ffmpeg = runtime.ffmpegFolder;
QString ext    = runtime.audioExtension;





optional[i].id = QString(s.ids[p.keyId]);
optional[i].label = QString(s.labels[p.keyLabel]);


optional[i].id = s.ids.value(p.keyId, QString());
optional[i].label = s.labels.value(p.keyLabel, QString());


DownloadThread内で

	RuntimeConfig runtime;
	runtime.applySettings(settings);
	
	optional1 = runtime.optional[0].id;
	optional2 = runtime.optional[1].id;
	optional3 = runtime.optional[2].id;
	optional4 = runtime.optional[3].id;
	optional5 = runtime.optional[4].id;
	optional6 = runtime.optional[5].id;
	optional7 = runtime.optional[6].id;
	optional8 = runtime.optional[7].id;
	special1 = runtime.spec[0].id;
	special2 = runtime.spec[1].id;
	special3 = runtime.spec[2].id;
	special4 = runtime.spec[3].id;




std::unique_ptr<RuntimeConfig> runtime;

runtime = std::make_unique<RuntimeConfig>();
runtime->applySettings(settings);
runtime->applyGui(gui);

downloadThread = new DownloadThread(Settings::instance(), runtime.get(), ui);





const ProgramEntry &optionalProgram(int index) const {
    return optional[index];
}

const ProgramEntry &specProgram(int index) const {
    return spec[index];
}

optional1 = runtime.optionalProgram(0).id;
optional2 = runtime.optionalProgram(1).id;
optional3 = runtime.optionalProgram(2).id;
optional4 = runtime.optionalProgram(3).id;
optional5 = runtime.optionalProgram(4).id;
optional6 = runtime.optionalProgram(5).id;
optional7 = runtime.optionalProgram(6).id;
optional8 = runtime.optionalProgram(7).id;

special1 = runtime.specProgram(0).id;
special2 = runtime.specProgram(1).id;
special3 = runtime.specProgram(2).id;
special4 = runtime.specProgram(3).id;




guistate.h

#pragma once
#include <QMap>
#include <QString>

class MainWindow;

struct GuiState
{
    QMap<QString,bool> flags;

    static GuiState fromMainWindow(const MainWindow& w);
};



guistate.cpp

#include "guistate.h"
#include "mainwindow.h"
#include "constants_flag.h"

GuiState GuiState::fromMainWindow(const MainWindow& w)
{
    GuiState s;

    // FlagTableを使って全部まとめて収集
    for (int i = 0; i < Constants::FlagCount; ++i) {
        const auto &f = Constants::FlagTable[i];
        s.flags[f.keyFlag] = w.guiFlagValue(f.keyFlag);
    }

    return s;
}

bool guiFlagValue(const QString& key) const;

bool MainWindow::guiFlagValue(const QString& key) const
{
    if (key == KEY_LAST_WEEK)   return ui->checkLastWeek->isChecked();
    if (key == KEY_PROGRAM_LIST)return programListMode;
    if (key == KEY_NOGUI)       return false; // GUIでは常にfalse

    return false;
}

void RuntimeConfig::applyGui(const GuiState& g)
{
    for (auto it = g.flags.begin(); it != g.flags.end(); ++it) {
        setFlag(it.key(), it.value());
    }
}

void MainWindow::onRun()
{
    GuiState gui = GuiState::fromMainWindow(*this);

    RuntimeConfig rc;
    rc.applySettings(settings);
    rc.applyCommandLine(cli);
    rc.applyGui(gui);

    runner.start(rc);
}







void Settingsdialog::pushbutton_2()
{
    QStringList labels;

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        auto &repo = ProgramRepository::instance();
        labels << repo.id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + labels[0] + "\n" +
        "２：" + labels[1] + "\n" +
        "３：" + labels[2] + "\n" +
        "４：" + labels[3];

    if (QMessageBox::question(this, tr("特別番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::PRESET_SIZE; ++i)
            settings.specials[i] = edits[i]->text();
    }
}


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // ★ 番組一覧の初期化（非同期）
    auto &repo = ProgramRepository::instance();
    repo.updatePrograms();

    // ★ 番組一覧更新後に UI を更新したい場合
    connect(&repo, &ProgramRepository::programListUpdated,
            this, &MainWindow::onProgramListUpdated);
}

Settingsdialog::Settingsdialog(Settings& ini, QWidget *parent)
    : QDialog(parent), ui(new Ui::Settingsdialog), settings(ini)


auto &repo = ProgramRepository::instance();
repo.name_map
repo.id_map
repo.thumbnail_map


auto &repo = ProgramRepository::instance();
if (repo.id_map.isEmpty()) {
    QMessageBox::warning(this, "情報取得中", "番組一覧を取得中です。しばらくお待ちください。");
    return;
}






private:
    static QString iniFilePath();


QString Settings::iniFilePath()
{
#ifdef Q_OS_MACOS
    QString dir =
        QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);
    return dir + QDir::separator() + Constants::IniFileName;
#else
    QString dir = QCoreApplication::applicationDirPath();
    return dir + QDir::separator() + Constants::IniFileName;
#endif
}

void Settings::load()
{
    QSettings ini(iniFilePath(), QSettings::IniFormat);


void Settings::save()
{
    QSettings ini(iniFilePath(), QSettings::IniFormat);



1. macOS飲みiniファイルの保存パスが異なる。という仕様が漏れていたので追加が必要。
2.iniファイルの保存先はsettingsが持ち役割で良いか？
3.load/saveで使えるように共通関数にしたい。

#ifdef Q_OS_MACOS
	QString result = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation) + "/";
	result += QDir::separator();
	ini_file_path = result + Constants::IniFileName;
#endif
#if !defined( Q_OS_MACOS )
	QString result = QCoreApplication::applicationDirPath();
	result += QDir::separator();
	ini_file_path = result + Constants::IniFileName;
#endif	


save側の現在
void Settings::saveProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    ini.setValue(p.keyChecked, checked[p.keyChecked]);

    if (!qs(p.keyId).isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!qs(p.keyLabel).isEmpty())
        ini.setValue(p.keyLabel, labels[p.keyLabel]);
}

上記を下記に書き換える
void Settings::saveProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked
    ini.setValue(p.keyChecked, checked[p.keyChecked]);

    // id
    if (p.saveId)
        ini.setValue(p.keyId, ids[p.keyId]);

    // label
    if (p.saveLabel)
        ini.setValue(p.keyLabel, labels[p.keyLabel]);
}

void Settings::loadProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id
    if (p.hasId) {
        if (p.saveId) {
            ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();
        } else {
            ids[p.keyId] = QString::fromUtf8(p.idDefault);
        }
    }

    // label
    if (p.hasLabel) {
        if (p.saveLabel) {
            labels[p.keyLabel] = ini.value(p.keyLabel, p.labelDefault).toString();
        } else {
            labels[p.keyLabel] = QString::fromUtf8(p.labelDefault);
        }
    }
}



struct ProgramDefinition {
    enum class Kind {
        English,
        Optional,
        Spec,
        Feature
    };

    Kind kind;

    const char* keyChecked;
    bool checkedDefault;

    const char* keyId;
    const char* idDefault;
    bool hasId;

    const char* keyLabel;
    const char* labelDefault;
    bool hasLabel;

    const char* objectName;
};


void Settings::loadProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked（必須）
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id（存在する場合のみ）
    if (p.hasId) {
        ids[p.keyId] =
            ini.value(p.keyId, p.idDefault).toString();
    }

    // label（存在する場合のみ）
    if (p.hasLabel) {
        labels[p.keyLabel] =
            ini.value(p.keyLabel, p.labelDefault).toString();
    }
}





void Settings::loadProgramDefinition(const Constants::ProgramDefinition &p, QSettings &ini)
{
    // checked
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id
    if (!qs(p.keyId).isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // label
    if (!qs(p.keyLabel).isEmpty())
        labels[p.keyLabel] = ini.value(p.keyLabel, p.labelDefault).toString();
}



struct ProgramDefinition {
    enum class Kind {
        English,   // 固定番組
        Optional,  // 任意設定番組
        Spec,      // 特番
        Feature    // チェックボックス
    };

    Kind kind;

    // checked の保存キーとデフォルト値
    const char* keyChecked;
    bool    checkedDefault;

    // id の保存キーとデフォルト値（English/Feature は空）
    const char* keyId;
    const char* idDefault;

    // label の保存キーとデフォルト値（English は固定値、Feature は空）
    const char* keyLabel;
    const char* labelDefault;

    // UI の objectName（Feature で空の場合もある）
    const char* objectName;
};



void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramDefinition(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramDefinition(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramDefinition(p, ini);
    for (const auto &p : Constants::FeatureSettings)  loadProgramDefinition(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();
 
     // ===== 初期値設定（未設定の場合のみ） =====
    initDefaultSaveFolder();

    // ===== 妥当性チェック（存在しないフォルダなら空にする） =====
    validateSaveFolder();
       
    // ===== 初回起動時の OS 別初期化 =====
    initDefaultFfmpegFolder();

    // 妥当性確認（壊れたパスなら空にする）
    if (!isValidFfmpegFolder(ffmpegFolder)) {
        ffmpegFolder.clear();
    }

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}




#include <QTimer>

int main(int argc, char *argv[])
{
#if defined(QT_NO_DEBUG)
#ifdef QT4_QT5_WIN
    const char* null = "nul";
#else
    const char* null = "/dev/null";
#endif
    freopen(null, "a", stdout);
    freopen(null, "a", stderr);
#endif

    QApplication a(argc, argv);
    MainWindow w;

    if (Utility::nogui()) {
        QTimer::singleShot(0, &w, SLOT(download()));
    } else {
        w.show();
    }

    return a.exec();
}




inline constexpr std::size_t OPT_PRESET_SIZE = OptionalCount;
inline constexpr std::size_t PRESET_SIZE = SpecCount;


file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:25,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:6:39: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
    6 |     inline constexpr char*  AppName = "語学講座ＣＳ２";
      |                                       ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:7:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
    7 |     inline constexpr char*  AppVersion = "2026/01/29";
      |                                          ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:10:43: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   10 |     inline constexpr char*  IniFileName = "CaptureStream2.ini";
      |                                           ^~~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:13:56: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   13 |     inline constexpr char*  SETTING_GROUP_MainWindow = "MainWindow";
      |                                                        ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:14:61: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   14 |    inline constexpr char*  SETTING_GROUP_CustomizeDialog = "CustomizeDialog";
      |                                                            ^~~~~~~~~~~~~~~~~

/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:15:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   15 |     inline constexpr char*  SETTING_GROUP_MessageWindow = "MessageWindow";
      |                                                           ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:16:60: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   16 |     inline constexpr char*  SETTING_GROUP_ScrambleDialog = "ScrambleDialog";
      |                                                            ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:17:60: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   17 |     inline constexpr char*  SETTING_GROUP_Settingsdialog = "Settingsdialog";
      |                                                            ^~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:20:50: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   20 |     inline constexpr char*  KEY_AudioExtension = "audio_extension";
      |                                                  ^~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:21:54: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   21 |     inline constexpr char*  DEFAULT_AudioExtension = "m4a";
      |                                                      ^~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:25:50: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   25 |     inline constexpr char*  KEY_SaveFolder     = "save_folder";
      |                                                  ^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:26:50: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   26 |     inline constexpr char*  KEY_FfmpegFolder   = "ffmpeg_folder";
      |                                                  ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:29:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   29 |     inline constexpr char*  KEY_basic0 = "basic0";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:30:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   30 |     inline constexpr char*  KEY_basic1 = "basic1";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:31:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   31 |     inline constexpr char*  KEY_basic2 = "basic2";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:32:45: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   32 |     inline constexpr char*  KEY_timetrial = "timetrial";
      |                                             ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:33:41: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   33 |     inline constexpr char*  KEY_enjoy = "enjoy";
      |                                         ^~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:34:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   34 |     inline constexpr char*  KEY_kaiwa =  "kaiwa";
      |                                          ^~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:35:44: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   35 |     inline constexpr char*  KEY_business = "business1";
      |                                            ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:36:42: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   36 |     inline constexpr char*  KEY_gendai = "gendai";
      |                                          ^~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:39:51: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   39 |     inline constexpr char*  KEY_KOZA_SEPARATION = "koza_separation";
      |                                                   ^~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:40:45: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   40 |     inline constexpr char*  KEY_MULTI_GUI = "multi_gui";
      |                                             ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:41:46: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   41 |     inline constexpr char*  KEY_NAME_SPACE = "name_space";
      |                                              ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:42:45: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   42 |     inline constexpr char*  KEY_TAG_SPACE = "tag_space";
      |                                             ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:43:43: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   43 |     inline constexpr char*  KEY_NOGUI   = "nogui";              // CLI: -nogui
      |                                           ^~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:44:51: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   44 |     inline constexpr char*  KEY_LAST_WEEK       = "last_week";          // GUI: [前週]、CLI: -z
      |                                                   ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:45:51: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   45 |     inline constexpr char*  KEY_BOTH_WEEKS      = "both_weeks";         // CLI: -b
      |                                                   ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:46:48: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   46 |     inline constexpr char*  KEY_PROGRAM_LIST = "program_list";  // GUI: 番組一覧表示
      |                                                ^~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:49:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   49 |     inline constexpr char*  KEY_CUSTOMIZED_TITLE1       = "customized_title1";
      |                                                           ^~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:50:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   50 |     inline constexpr char*  KEY_CUSTOMIZED_TITLE2       = "customized_title2";
      |                                                           ^~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:51:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   51 |     inline constexpr char*  KEY_CUSTOMIZED_FILENAME1    = "customized_file_name1";
      |                                                           ^~~~~~~~~~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_core.h:52:59: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   52 |     inline constexpr char*  KEY_CUSTOMIZED_FILENAME2    = "customized_file_name2";
      |                                                           ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:62:51: error: the value of ‘Constants::OPT_PRESET_SIZE’ is not usable in a constant expression
   62 |     std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
      |                                                   ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:173:22: note: ‘Constants::OPT_PRESET_SIZE’ was not initialized with a constant expression
  173 |     extern const int OPT_PRESET_SIZE = OptionalCount;
      |                      ^~~~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:62:51: note: in template argument for type ‘long unsigned int’
   62 |     std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
      |                                                   ^
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:63:47: error: the value of ‘Constants::PRESET_SIZE’ is not usable in a constant expression
   63 |     std::array<QString, Constants::PRESET_SIZE> specials;
      |                                               ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:195:22: note: ‘Constants::PRESET_SIZE’ was not initialized with a constant expression
  195 |     extern const int PRESET_SIZE = SpecCount;
      |                      ^~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:63:47: note: in template argument for type ‘long unsigned int’
   63 |     std::array<QString, Constants::PRESET_SIZE> specials;
      |                                               ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:41,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:53:39: error: size of array ‘english’ is not an integral constant-expression
   53 |     RuntimeProgram english[Constants::EnglishCount];
      |                            ~~~~~~~~~~~^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:54:40: error: size of array ‘optional’ is not an integral constant-expression
   54 |     RuntimeProgram optional[Constants::OptionalCount];
      |                             ~~~~~~~~~~~^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:55:36: error: size of array ‘spec’ is not an integral constant-expression
   55 |     RuntimeProgram spec[Constants::SpecCount];
      |                         ~~~~~~~~~~~^~~~~~~~~
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../runtimeconfig.h:56:30: error: size of array ‘checkBox’ is not an integral constant-expression
   56 |     bool checkBox[Constants::FeatureCount];
      |                   ~~~~~~~~~~~^~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_scrambledialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:7:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../scrambledialog.h:53:54: error: the value of ‘Constants::OPT_PRESET_SIZE’ is not usable in a constant expression
   53 |     std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;
      |                                                      ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:173:22: note: ‘Constants::OPT_PRESET_SIZE’ was not initialized with a constant expression
  173 |     extern const int OPT_PRESET_SIZE = OptionalCount;
      |                      ^~~~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_scrambledialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:7:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../scrambledialog.h:53:54: note: in template argument for type ‘long unsigned int’
   53 |     std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;
      |                                                      ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_settingsdialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:8:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settingsdialog.h:53:50: error: the value of ‘Constants::PRESET_SIZE’ is not usable in a constant expression
   53 |     std::array<QLineEdit*, Constants::PRESET_SIZE> edits;
      |                                                  ^
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants.h:26,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settings.h:29,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../downloadthread.h:31,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_downloadthread.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:4:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../constants_programs.h:195:22: note: ‘Constants::PRESET_SIZE’ was not initialized with a constant expression
  195 |     extern const int PRESET_SIZE = SpecCount;
      |                      ^~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/moc_settingsdialog.cpp:9,
                 from /home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/mocs_compilation.cpp:8:
/home/kazuo/cs/CaptureStream2/CaptureStream2_autogen/EWIEGA46WW/../../settingsdialog.h:53:50: note: in template argument for type ‘long unsigned int’
   53 |     std::array<QLineEdit*, Constants::PRESET_SIZE> edits;
      |                                                  ^
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:85: CMakeFiles/CaptureStream2.dir/CaptureStream2_autogen/mocs_compilation.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2




struct ProgramDefinition {
    enum class Kind {
        English,   // 固定番組
        Optional,  // 任意設定番組
        Spec,      // 特番
        Feature    // チェックボックス
    };

    Kind kind;

    // checked の保存キーとデフォルト値
    const char* keyChecked;
    bool    checkedDefault;

    // id の保存キーとデフォルト値（English/Feature は空）
    const char* keyId;
    const char* idDefault;
    bool hasId;

    // label の保存キーとデフォルト値（English は固定値、Feature は空）
    const char* keyLabel;
    const char* labelDefault;
    bool hasLabel;

    // UI の objectName（Feature で空の場合もある）
    const char* objectName;
};






エラーメッセージ
QVector<ProgramEntry> RuntimeConfig::allPrograms() const
を
QVector<RuntimeConfig::ProgramEntry> RuntimeConfig::allPrograms() const
に変更するとエラーは消える
Constants::ProgramEntryは全てリネーム済み



[ 83%] Building CXX object CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:118:9: error: ‘ProgramEntry’ was not declared in this scope
  118 | QVector<ProgramEntry> RuntimeConfig::allPrograms() const
      |         ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:118:21: error: template argument 1 is invalid
  118 | QVector<ProgramEntry> RuntimeConfig::allPrograms() const
      |                     ^
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:118:23: error: no declaration matches ‘int RuntimeConfig::allPrograms() const’
  118 | QVector<ProgramEntry> RuntimeConfig::allPrograms() const
      |                       ^~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:24:
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:96:27: note: candidate is: ‘QVector<RuntimeConfig::ProgramEntry> RuntimeConfig::allPrograms() const’
   96 |     QVector<ProgramEntry> allPrograms() const;
      |                           ^~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:41:7: note: ‘class RuntimeConfig’ defined here
   41 | class RuntimeConfig
      |       ^~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:155:9: error: ‘ProgramEntry’ was not declared in this scope
  155 | QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
      |         ^~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:155:21: error: template argument 1 is invalid
  155 | QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
      |                     ^
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:155:23: error: no declaration matches ‘int RuntimeConfig::checkedPrograms() const’
  155 | QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
      |                       ^~~~~~~~~~~~~
In file included from /home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:24:
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:98:27: note: candidate is: ‘QVector<RuntimeConfig::ProgramEntry> RuntimeConfig::checkedPrograms() const’
   98 |     QVector<ProgramEntry> checkedPrograms() const;
      |                           ^~~~~~~~~~~~~~~
/home/kazuo/cs/CaptureStream2/runtimeconfig.h:41:7: note: ‘class RuntimeConfig’ defined here
   41 | class RuntimeConfig
      |       ^~~~~~~~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:253: CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2




ProgramDefinition


struct ProgramEntry
{
    bool checked;        // 有効かどうか
    QString id;          // 実行に使う ID
    QString label;       // 表示用ラベル
    QString category;    // "english" / "optional" / "spec"
};

QVector<ProgramEntry> allPrograms() const;

QVector<ProgramEntry> checkedPrograms() const;

QVector<ProgramEntry> RuntimeConfig::allPrograms() const
{
    QVector<ProgramEntry> list;

    // English
    for (int i = 0; i < Constants::EnglishCount; i++) {
        ProgramEntry e;
        e.checked  = english[i].checked;
        e.id       = english[i].id;
        e.label    = english[i].label;
        e.category = "english";
        list.append(e);
    }

    // Optional
    for (int i = 0; i < Constants::OptionalCount; i++) {
        ProgramEntry e;
        e.checked  = optional[i].checked;
        e.id       = optional[i].id;
        e.label    = optional[i].label;
        e.category = "optional";
        list.append(e);
    }

    // Spec
    for (int i = 0; i < Constants::SpecCount; i++) {
        ProgramEntry e;
        e.checked  = spec[i].checked;
        e.id       = spec[i].id;
        e.label    = spec[i].label;
        e.category = "spec";
        list.append(e);
    }

    return list;
}

QVector<ProgramEntry> RuntimeConfig::checkedPrograms() const
{
    QVector<ProgramEntry> list;

    // English
    for (int i = 0; i < Constants::EnglishCount; i++) {
        if (english[i].checked) {
            ProgramEntry e;
            e.checked  = true;
            e.id       = english[i].id;
            e.label    = english[i].label;
            e.category = "english";
            list.append(e);
        }
    }

    // Optional
    for (int i = 0; i < Constants::OptionalCount; i++) {
        if (optional[i].checked) {
            ProgramEntry e;
            e.checked  = true;
            e.id       = optional[i].id;
            e.label    = optional[i].label;
            e.category = "optional";
            list.append(e);
        }
    }

    // Spec
    for (int i = 0; i < Constants::SpecCount; i++) {
        if (spec[i].checked) {
            ProgramEntry e;
            e.checked  = true;
            e.id       = spec[i].id;
            e.label    = spec[i].label;
            e.category = "spec";
            list.append(e);
        }
    }

    return list;
}

for (auto &p : config.checkedPrograms()) {
    runProgram(p.id);
}








#pragma once
#include <QString>
#include <QMap>
#include <vector>
#include <optional>

#include "settings.h"
#include "clioptions.h"
#include "constants.h"

class RuntimeConfig
{
public:
    RuntimeConfig();

    void applySettings(const Settings &s);
    void applyCommandLine(const CliOptions &cli);

    void setFlag(const QString &key, bool value);
    bool flag(const QString &key) const;

public:
    // ===== GUI: English / Optional / Spec =====
    ProgramEntry english[Constants::EnglishCount];
    ProgramEntry optional[Constants::OptionalCount];
    ProgramEntry spec[Constants::SpecCount];

    // ===== GUI: Feature チェックボックス =====
    bool checkBox[Constants::FeatureCount];

    // ===== GUI: その他設定 =====
    QString saveFolder;
    QString ffmpegFolder;
    QString audioExtension;

    // ===== GUI: CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    // ===== CLI: 録画設定 =====
    std::optional<QString> cliTitleTagFormat;   // -t
    std::optional<QString> cliFileNameFormat;   // -f
    std::optional<QString> cliOutputFolder;     // -o
    std::optional<QString> cliExtension;        // -e

    std::vector<QString> cliProgramIds;

    // ===== flags（GUI + CLI 統合）=====
    QMap<QString, bool> flags;
};


#include "runtimeconfig.h"
#include "constants.h"

RuntimeConfig::RuntimeConfig()
{
    // flags 初期化
    for (int i = 0; i < Constants::FlagCount; ++i) {
        const auto &f = Constants::FlagTable[i];
        flags[f.keyFlag] = f.flagDefault;
    }
}

void RuntimeConfig::applySettings(const Settings &s)
{
    // ===== English =====
    for (int i = 0; i < Constants::EnglishCount; i++) {
        const auto &p = Constants::EnglishPrograms[i];
        english[i].checked = s.checked[p.keyChecked];
        english[i].id      = p.idDefault;
        english[i].label   = p.labelDefault;
    }

    // ===== Optional =====
    for (int i = 0; i < Constants::OptionalCount; i++) {
        const auto &p = Constants::OptionalPrograms[i];
        optional[i].checked = s.checked[p.keyChecked];
        optional[i].id      = s.ids[p.keyId];
        optional[i].label   = s.labels[p.keyLabel];
    }

    // ===== Spec =====
    for (int i = 0; i < Constants::SpecCount; i++) {
        const auto &p = Constants::SpecPrograms[i];
        spec[i].checked = s.checked[p.keyChecked];
        spec[i].id      = s.ids[p.keyId];
        spec[i].label   = s.labels[p.keyLabel];
    }

    // ===== Feature（チェックボックス）=====
    for (int i = 0; i < Constants::FeatureCount; i++) {
        const auto &p = Constants::FeatureSettings[i];
        checkBox[i] = s.checked[p.keyChecked];
        setFlag(p.keyChecked, s.checked[p.keyChecked]);
    }

    // ===== その他設定 =====
    saveFolder     = s.saveFolder;
    ffmpegFolder   = s.ffmpegFolder;
    audioExtension = s.audioExtension;

    // ===== CustomizeDialog =====
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        titleFormat[i]    = s.titleFormat[i];
        fileNameFormat[i] = s.fileNameFormat[i];
    }
}

void RuntimeConfig::applyCommandLine(const CliOptions &cli)
{
    // ===== CLI: 録画設定 =====
    if (cli.titleTagFormat)
        cliTitleTagFormat = *cli.titleTagFormat;

    if (cli.fileNameFormat)
        cliFileNameFormat = *cli.fileNameFormat;

    if (cli.outputFolder)
        cliOutputFolder = *cli.outputFolder;

    if (cli.extension)
        cliExtension = *cli.extension;

    if (!cli.programIds.empty())
        cliProgramIds = cli.programIds;

    // ===== CLI: flags =====
    for (const auto &key : cli.enabledKeys)
        setFlag(key, true);
}

void RuntimeConfig::setFlag(const QString &key, bool value)
{
    flags[key] = value;
}

bool RuntimeConfig::flag(const QString &key) const
{
    return flags.value(key, false);
}









GUIも含めてsettingsの下記の部分がrunntimeConfigに反映されていない
    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();



 1. clioptions.h（CLI 専用構造体）

#pragma once
#include <QString>
#include <vector>
#include <optional>

struct CliOptions {
    bool nogui = false;

    std::vector<QString> programIds;

    std::optional<QString> titleTagFormat;   // -t
    std::optional<QString> fileNameFormat;   // -f
    std::optional<QString> outputFolder;     // -o
    std::optional<QString> extension;        // -e

    bool optionZ = false;  // -z
    bool optionB = false;  // -b
    bool optionS = false;  // -s

    // ★ CLI が有効化した keyOption を保持
    std::vector<QString> enabledKeys;
};


---

✅ 2. commandlineparser.h

#pragma once
#include "clioptions.h"

class CommandLineParser {
public:
    static CliOptions parse(int argc, char* argv[]);
};


---

✅ 3. commandlineparser.cpp（keyOption 対応版）

#include "commandlineparser.h"
#include "constants.h"
#include <QString>

CliOptions CommandLineParser::parse(int argc, char* argv[])
{
    CliOptions opts;

    auto findOption = [&](const QString& arg) -> const Constants::CliOption* {
        for (int i = 0; i < Constants::OPTION_TABLE_COUNT; ++i) {
            if (arg == Constants::OPTION_TABLE[i].name)
                return &Constants::OPTION_TABLE[i];
        }
        return nullptr;
    };

    for (int i = 1; i < argc; ++i) {
        QString arg = argv[i];
        const Constants::CliOption* opt = findOption(arg);

        if (!opt) {
            // プログラムIDとして扱う
            opts.programIds.push_back(arg);
            continue;
        }

        // 値を取るオプション
        if (opt->requiresValue) {
            if (i + 1 >= argc)
                break;

            QString value = argv[++i];

            if (arg == "-t")      opts.titleTagFormat = value;
            else if (arg == "-f") opts.fileNameFormat = value;
            else if (arg == "-o") opts.outputFolder   = value;
            else if (arg == "-e") opts.extension      = value;

            // ★ keyOption を登録
            opts.enabledKeys.push_back(opt->keyOption);
        }
        else {
            // 値を取らないオプション
            if (arg == "-nogui") opts.nogui = true;
            else if (arg == "-z") opts.optionZ = true;
            else if (arg == "-b") opts.optionB = true;
            else if (arg == "-s") opts.optionS = true;

            // ★ keyOption を登録
            opts.enabledKeys.push_back(opt->keyOption);
        }
    }

    return opts;
}


---

✅ 4. runtimeconfig.h（applyCommandLine を CliOptions 版に変更）

void applyCommandLine(const CliOptions &cli);


---

✅ 5. runtimeconfig.cpp（flags 連動版）

#include "runtimeconfig.h"
#include "clioptions.h"

void RuntimeConfig::applyCommandLine(const CliOptions &cli)
{
    //
    // 1. 値を持つオプション
    //
    if (cli.outputFolder)
        saveFolder = *cli.outputFolder;

    if (cli.extension)
        audioExtension = *cli.extension;

    if (cli.titleTagFormat)
        titleTagFormat = *cli.titleTagFormat;

    if (cli.fileNameFormat)
        fileNameFormat = *cli.fileNameFormat;

    //
    // 2. フラグ系（-s, -z, -b, -nogui）
    //
    if (cli.optionS) optionS = true;
    if (cli.optionZ) optionZ = true;
    if (cli.optionB) optionB = true;
    if (cli.nogui)   nogui   = true;

    //
    // 3. programIds（CLI 専用）
    //
    if (!cli.programIds.empty())
        programIds = cli.programIds;

    //
    // 4. flags に反映（GUI と CLI の統合ポイント）
    //
    for (const auto &key : cli.enabledKeys)
        setFlag(key, true);
}


---



    // CLIコマンドラインオプション
struct CliOption {
    const char* name;
    bool requiresValue;
    QString keyOption;	// GUI、Flagの キーと一致
    QString description;
};

inline const CliOption OPTION_TABLE[] = {
    { "-nogui", false,	KEY_NOGUI,		"GUI を起動せずに実行します" },
    { "-t",     true,	KEY_CUSTOMIZED_TITLE1,	"タイトルタグ形式を指定します" },
    { "-f",     true,	KEY_CUSTOMIZED_FILENAME1, "ファイル名形式を指定します" },
    { "-o",     true,	KEY_SaveFolder,		"保存フォルダのフルパスを指定します" },
    { "-e",     true,	KEY_AudioExtension,	"拡張子を指定します" },
    { "-z",     false,	KEY_LAST_WEEK,		"前週の動作を行います" },
    { "-b",     false,	KEY_BOTH_WEEKS,		"前週と当週の両方を実行します" },
    { "-s",     false,	KEY_KOZA_SEPARATION,	"応用編分離を有効にします" },
};

constexpr int OPTION_TABLE_COUNT = std::size(OPTION_TABLE);



void RuntimeConfig::applyRecordingConfig(const RecordingConfig &rc)
{
    setFlag(Constants::KEY_NOGUI, rc.nogui);
    setFlag(Constants::KEY_Z, rc.optionZ);
    setFlag(Constants::KEY_B, rc.optionB);
    setFlag(Constants::KEY_S, rc.optionS);
}


[ 11%] Building CXX object CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp: In member function ‘void RuntimeConfig::applyCommandLine(const QMap<QString, QString>&)’:
/home/kazuo/cs/CaptureStream2/runtimeconfig.cpp:124:35: error: ‘rc’ was not declared in this scope
  124 |     setFlag(Constants::KEY_NOGUI, rc.nogui);
      |                                   ^~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:253: CMakeFiles/CaptureStream2.dir/runtimeconfig.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2


void RuntimeConfig::applyRecordingConfig(const RecordingConfig &rc)
{
    setFlag("nogui", rc.nogui);
    setFlag("z", rc.optionZ);
    setFlag("b", rc.optionB);
    setFlag("s", rc.optionS);

    // 必要なら他の CLI オプションもここで統合
}




void RuntimeConfig::setFlag(const QString &key, bool value)
{
    flags[key] = value;
}

bool RuntimeConfig::flag(const QString &key) const
{
    return flags.value(key, false);
}


private:
    QMap<QString, bool> flags;


/* ============================================================
 * Flag（チェックボックス、CLIオプションなど）
 * ------------------------------------------------------------
 * ini ファイルに保存されない RuntimeConfig で使用する Flag。
 * RuntimeConfig 生成時に default で初期化され、
 * Settings / GUI / CLI によって上書きされる。
 * Feature と重複する場合は後からの値が優先される。
 * ========================================================== */   

struct FlagEntry {
    QString keyFlag;      // 例: "nogui"
    bool flagDefault;     // 初期値
};

inline const FlagEntry FlagTable[] = {
    { "nogui",        false }, // CLI: --nogui
    { "last_week",    false }, // GUI: [前週]
    { "both_weeks",   false }, // GUI: [前週+今週]
    { "program_list", false }, // GUI: 番組一覧表示
    { "featureX",     true  }  // Settings Feature
};

// ===== フラグの数 =====
constexpr int FlagCount = std::size(FlagTable);


namespace Constants {

struct FlagEntry {
    QString key;      // "previewEnabled" など
    bool defaultValue;
};

static const FlagEntry FlagTable[] = {
    { "previewEnabled", false },
    { "useNewMode",     false },
    { "featureX",       true  }, // ini に保存される Feature でもよい
    // ...
};


void RuntimeConfig::applySettings(const Settings &s)
{
    // Feature 系（ini に保存されるもの）
    for (int i = 0; i < Constants::FeatureCount; i++) {
        const auto &p = Constants::FeatureSettings[i];
        bool v = s.checked[p.keyChecked];
        checkBox[i] = v;
        setFlag(p.keyChecked, v);   // flags にも反映
    }

    // その他の Settings も必要に応じて flags にマージしてよい
}



static const int FlagCount = sizeof(FlagTable) / sizeof(FlagEntry);

} // namespace Constants


RuntimeConfig::RuntimeConfig()
{
    // すべてのフラグを定義済みの初期値で埋める
    for (int i = 0; i < Constants::FlagCount; ++i) {
        const auto &f = Constants::FlagTable[i];
        flags[f.key] = f.defaultValue;
    }
}




void MainWindow::customizeSaveFolder()
{
    auto &s = Settings::instance();
    QString base = s.saveFolder;

#if defined(Q_OS_WIN)
    QString folderPath;
    if (isWineEnvironment()) {
        folderPath = getPortableFolderDialog(
            this,
            tr("書き込み可能な保存フォルダを指定してください"),
            base
        );
    } else {
        folderPath = QFileDialog::getExistingDirectory(
            this,
            tr("書き込み可能な保存フォルダを指定してください"),
            base,
            QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
        );
    }
    QString dir = QFileInfo(folderPath).absoluteFilePath();
#else
    QString dir = QFileDialog::getExistingDirectory(
        this,
        tr("書き込み可能な保存フォルダを指定してください"),
        base,
        QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
    );
#endif

    if (!dir.isEmpty()) {
        s.saveFolder = dir + QDir::separator();
    }
}

void MainWindow::customizeFolderOpen()
{
    auto &s = Settings::instance();
    QString folder = s.saveFolder;

    bool success = false;

#if defined(Q_OS_WIN)
    if (isWineEnvironment()) {
        QString dir = convertWinePathToUnix(folder);
        openUrlWithFallbackDialog(QUrl::fromLocalFile(dir), this);
        success = true;
    } else {
        success = QDesktopServices::openUrl(QUrl("file:///" + folder, QUrl::TolerantMode));
    }
#elif defined(Q_OS_MAC)
    success = QDesktopServices::openUrl(QUrl("file:///" + folder, QUrl::TolerantMode));
#elif defined(Q_OS_LINUX)
    QString dir = convertWinePathToUnixAuto(folder);
    QString cmd = QString("xdg-open \"%1\"").arg(dir);
    openUrlWithFallbackDialog(QUrl::fromLocalFile(dir), this);
    success = QProcess::startDetached("/bin/sh", QStringList() << "-c" << cmd);
    if (!success) {
        success = QDesktopServices::openUrl(folder);
    }
#else
    success = QDesktopServices::openUrl(QUrl("file:///" + folder, QUrl::TolerantMode));
    if (!success) {
        success = QDesktopServices::openUrl(folder);
    }
#endif

    if (!success) {
        success = QDesktopServices::openUrl(folder);
    }

    if (!success) {
        QString fallbackMessage =
            tr("フォルダを開くことができませんでした。\nパス: %1").arg(folder);
        QMessageBox::warning(nullptr, tr("エラー"), fallbackMessage);
    }
}

void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    if (s.saveFolder.isEmpty()) {
        customizeSaveFolder();
    }

    // 他の復元処理…
}


private:
    void initDefaultSaveFolder();          // OS別初期値設定
    void validateSaveFolder();             // 妥当性チェック

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    saveFolder = ini.value(Constants::KEY_SaveFolder).toString();

    ini.endGroup();

    // ===== 初期値設定（未設定の場合のみ） =====
    initDefaultSaveFolder();

    // ===== 妥当性チェック（存在しないフォルダなら空にする） =====
    validateSaveFolder();
}

void Settings::initDefaultSaveFolder()
{
    if (!saveFolder.isEmpty())
        return;  // すでに設定済みなら何もしない

#ifdef Q_OS_WIN
    saveFolder = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
#elif defined(Q_OS_MAC)
    saveFolder = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
#elif defined(Q_OS_LINUX)
    saveFolder = QDir::homePath();
#else
    saveFolder = QDir::homePath();
#endif

    // 最後は必ず末尾にセパレータを付ける
    if (!saveFolder.endsWith(QDir::separator()))
        saveFolder += QDir::separator();
}

void Settings::validateSaveFolder()
{
    if (saveFolder.isEmpty())
        return;

    QDir dir(saveFolder);

    // フォルダが存在しない場合は空にする
    if (!dir.exists()) {
        saveFolder.clear();
        return;
    }

    // 書き込み可能かどうかの最低限チェック
    QFileInfo testFile(dir.filePath(".__cs2_test__"));
    QFile f(testFile.absoluteFilePath());

    if (f.open(QIODevice::WriteOnly)) {
        f.close();
        f.remove();  // テストファイル削除
    } else {
        // 書き込み不可 → 空にする
        saveFolder.clear();
    }
}








public:
    QString detectFfmpegFolder();   // MainWindow から呼べる

QString Settings::detectFfmpegFolder()
{
    return autoDetectFfmpeg();   // private 関数を内部で呼ぶ
}

QString dir = Settings::instance().detectFfmpegFolder();



QString ffmpegFolder;

private:
    void initDefaultFfmpegFolder();
    QString autoDetectFfmpeg();   // OS別探索



settings cpp

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    ini.endGroup();

    // ===== 初回起動時の OS 別初期化 =====
    initDefaultFfmpegFolder();
}

void Settings::initDefaultFfmpegFolder()
{
    if (!ffmpegFolder.isEmpty())
        return;  // すでに設定済み

    // OS別に自動探索
    QString detected = autoDetectFfmpeg();
    if (!detected.isEmpty()) {
        ffmpegFolder = detected;
        return;
    }

    // 見つからなければ空のまま（MainWindow がダイアログを出す）
    ffmpegFolder.clear();
}

QString Settings::autoDetectFfmpeg()
{
    QProcess process;
    QString ffmpegPath;

#ifdef Q_OS_WIN
    process.start("cmd.exe", QStringList() << "/c" << "where" << "ffmpeg");
#else
    process.start("which", QStringList() << "ffmpeg");
#endif
    process.waitForFinished();

    ffmpegPath = QString::fromUtf8(process.readAllStandardOutput())
                     .split("\n").first().trimmed();

    if (!QFileInfo::exists(ffmpegPath)) {
#ifdef Q_OS_MAC
        QString arch = QSysInfo::buildCpuArchitecture();
        if (arch == "x86_64") {
            ffmpegPath = "/usr/local/bin/ffmpeg";
        } else if (arch == "arm64") {
            ffmpegPath = "/opt/homebrew/bin/ffmpeg";
            if (!QFile::exists(ffmpegPath))
                ffmpegPath = "/usr/local/bin/ffmpeg";
        }
#elif defined(Q_OS_LINUX)
        ffmpegPath = "/usr/bin/ffmpeg";
#elif defined(Q_OS_WIN)
        ffmpegPath = "C:\\Program Files\\ffmpeg\\bin\\ffmpeg.exe";
        if (!QFile::exists(ffmpegPath))
            ffmpegPath = "C:\\ffmpeg\\bin\\ffmpeg.exe";
#endif
    }

    if (QFile::exists(ffmpegPath))
        return QFileInfo(ffmpegPath).absolutePath();

    return QString();
}

mainwindowcっp
void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // ffmpeg が未設定なら設定ダイアログを開く
    if (s.ffmpegFolder.isEmpty()) {
        ffmpegFolderDialog();
    }

    // その他の復元処理…
}


void MainWindow::ffmpegFolderDialog()
{
    auto &s = Settings::instance();

    QMessageBox msgBox(this);
    QString message = QString::fromUtf8("ffmpegがあるフォルダを設定しますか？\n現在設定：\n") 
                      + s.ffmpegFolder;
    msgBox.setIcon(QMessageBox::Question);
    msgBox.setWindowTitle(tr("ffmpegがあるフォルダ設定"));
    msgBox.setText(message);

    QPushButton* setButton = msgBox.addButton(tr("設定する"), QMessageBox::ActionRole);
    QPushButton* searchButton = msgBox.addButton(tr("検索"), QMessageBox::ActionRole);
    QPushButton* bundledButton = msgBox.addButton(tr("同梱"), QMessageBox::ActionRole);
    QPushButton* resetButton = msgBox.addButton(tr("初期値に戻す"), QMessageBox::ActionRole);
    msgBox.setStandardButtons(QMessageBox::Cancel);

    if (msgBox.exec() == QMessageBox::Cancel)
        return;

    QPushButton* clicked = qobject_cast<QPushButton*>(msgBox.clickedButton());

    if (clicked == setButton) {

        QString dir = QFileDialog::getExistingDirectory(
            this, tr("ffmpegがあるフォルダを指定してください"),
            s.ffmpegFolder,
            QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

        if (!dir.isEmpty())
            s.ffmpegFolder = dir + QDir::separator();

    } else if (clicked == resetButton) {

        s.ffmpegFolder = Utility::applicationBundlePath();

    } else if (clicked == searchButton) {

        QString dir = Settings::instance().autoDetectFfmpeg();
        if (!dir.isEmpty()) {
            QString msg = QString::fromUtf8("ffmpegがある下記フォルダを見つけました。\n設定しますか？\n\n") + dir;
            if (QMessageBox::Yes == QMessageBox::question(this, tr("ffmpegフォルダ設定"), msg))
                s.ffmpegFolder = dir + QDir::separator();
        }

    } else if (clicked == bundledButton) {

        QString dir = Utility::applicationBundlePath();
        QString msg = QString::fromUtf8("同梱のffmpegを使用します。\n設定しますか？\n\n") + dir;
        if (QMessageBox::Yes == QMessageBox::question(this, tr("同梱ffmpeg設定"), msg))
            s.ffmpegFolder = dir + QDir::separator();
    }
}

private:
    bool isValidFfmpegFolder(const QString& folder) const;
    bool canExecuteFfmpeg(const QString& ffmpegPath) const;


bool Settings::isValidFfmpegFolder(const QString& folder) const
{
    if (folder.isEmpty())
        return false;

    QDir dir(folder);
    if (!dir.exists())
        return false;

#ifdef Q_OS_WIN
    QString exe = dir.filePath("ffmpeg.exe");
#else
    QString exe = dir.filePath("ffmpeg");
#endif

    if (!QFileInfo::exists(exe))
        return false;

    return canExecuteFfmpeg(exe);
}

bool Settings::canExecuteFfmpeg(const QString& ffmpegPath) const
{
    QProcess p;
    p.start(ffmpegPath, {"-version"});
    if (!p.waitForFinished(1500))  // タイムアウト短めでOK
        return false;

    return (p.exitStatus() == QProcess::NormalExit);
}


void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    ffmpegFolder = ini.value(Constants::KEY_FfmpegFolder).toString();

    ini.endGroup();

    // OS別初期値設定（未設定の場合のみ）
    initDefaultFfmpegFolder();

    // 妥当性確認（壊れたパスなら空にする）
    if (!isValidFfmpegFolder(ffmpegFolder)) {
        ffmpegFolder.clear();
    }
}





// audio_extension
if (auto combo = findChild<QComboBox*>("comboBox_extension")) {
    int index = combo->findText(s.audioExtension);
    if (index >= 0)
        combo->setCurrentIndex(index);
}

// saveFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_saveFolder"))
    edit->setText(s.saveFolder);

// ffmpegFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_ffmpegFolder"))
    edit->setText(s.ffmpegFolder);

// audio_extension
if (auto combo = findChild<QComboBox*>("comboBox_extension"))
    s.audioExtension = combo->currentText();

// saveFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_saveFolder"))
    s.saveFolder = edit->text();

// ffmpegFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_ffmpegFolder"))
    s.ffmpegFolder = edit->text();




void MainWindow::updateButtonUI(QToolButton* btn, bool checked, const QString& label)
{
    btn->blockSignals(true);
    btn->setChecked(checked);
    btn->blockSignals(false);

    if (label.isEmpty())
        return;

    static const QString mark = QString::fromUtf8("✓ ");

    btn->setText(checked ? mark + label : label);
}

void MainWindow::saveGui()
{
    auto &s = Settings::instance();

    // geometry 保存
    s.saveMainWindow(saveGeometry());

    // English / Optional / Spec / Feature をすべて保存
    saveProgramButtons(Constants::EnglishPrograms, s);
    saveProgramButtons(Constants::OptionalPrograms, s);
    saveProgramButtons(Constants::SpecPrograms, s);
    saveProgramButtons(Constants::FeatureSettings, s);

    // 最後に settings.ini へ保存
    s.save();
}

template <typename Container>
void MainWindow::saveProgramButtons(const Container &programs, Settings &s)
{
    for (const auto &p : programs) {
        if (p.objectName.isEmpty())
            continue;

        // QAbstractButton で統一（QToolButton も QCheckBox も継承）
        if (auto btn = findChild<QAbstractButton*>(p.objectName)) {
            s.checked[p.keyChecked] = btn->isChecked();
        }
    }
}



void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry 復元
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // ===== English =====
    updateProgramButtons(Constants::EnglishPrograms, s);
     // ===== Optional =====   
    updateProgramButtons(Constants::OptionalPrograms, s);
    // ===== Spec =====
    updateProgramButtons(Constants::SpecPrograms, s);
    // ===== Feature（チェックボックス）=====
    updateProgramButtons(Constants::FeatureSettings, s);
}

template <typename Container>
void MainWindow::updateProgramButtons(const Container &programs, const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString label;
            if (p.keyLabel.isEmpty()) {
                // English
                label = p.labelDefault;
            } else {
                // Optional / Spec
                label = s.labels[p.keyLabel];
            }

            updateButtonUI(btn, s.checked[p.keyChecked], label);
        }
    }
}

void MainWindow::updateButtonUI(QToolButton* btn, bool checked, const QString& baseLabel)
{
    const QString check = QString::fromUtf8("✓ ");

    btn->blockSignals(true);
    btn->setChecked(checked);
    btn->blockSignals(false);

    if (baseLabel.isEmpty()) return;
    QString text = baseLabel;
    if (checked) {		
        text.prepend(check);	            // 状態に応じて「✓」付与
    }
    btn->setText(text);
}






settings.h

#pragma once
#include <QString>
#include <QSettings>
#include <QMap>
#include <QVector>
#include <QByteArray>
#include "constants.h"

class Settings
{
public:
    static Settings& instance();

    void load();
    void save();

    // ===== MainWindow / MessageWindow =====
    void loadMainWindow();
    void saveMainWindow(const QByteArray &geometry);

    void loadMessageWindow();
    void saveMessageWindow(const QByteArray &geometry);

    // ===== 基本設定 =====
    QString audioExtension;
    QString ffmpegFolder;
    QString saveFolder;

    // ===== ProgramEntry の値（checked / id / label）=====
    // keyChecked → checked
    QMap<QString, bool> checked;

    // keyId → id
    QMap<QString, QString> ids;

    // keyLabel → label
    QMap<QString, QString> labels;

    // ===== optional / spec のプリセット =====
    std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
    std::array<QString, Constants::PRESET_SIZE> specials;

    // ===== geometry =====
    QByteArray mainWindowGeometry;
    QByteArray messageWindowGeometry;

    // ===== CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    static QString getTitleFormat(int index);
    static QString getFileNameFormat(int index);

    static void setTitleFormatValue(int index, const QString &value);
    static void setFileNameFormatValue(int index, const QString &value);

    // ===== CheckBox features =====
    static bool tagSpaceFlag();
    static bool nameSpaceFlag();
    static bool multiGuiFlag();
    static bool kozaSeparationFlag();

    static void setTagSpaceFlag(bool flag);
    static void setNameSpaceFlag(bool flag);
    static void setMultiGuiFlag(bool flag);
    static void setKozaSeparationFlag(bool flag);

private:
    Settings();
    Settings(const Settings&) = delete;
    Settings& operator=(const Settings&) = delete;

    // 内部ヘルパー
    void loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
    void saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
};



settings.cpp

#include "settings.h"
#include <QSettings>

Settings::Settings()
{
}

Settings& Settings::instance()
{
    static Settings inst;
    return inst;
}

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramEntry(p, ini);
    for (const auto &p : Constants::FeatureSettings)     loadProgramEntry(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}

void Settings::save()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて保存
    for (const auto &p : Constants::EnglishPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     saveProgramEntry(p, ini);
    for (const auto &p : Constants::FeatureSettings)     saveProgramEntry(p, ini);

    ini.setValue(Constants::KEY_AudioExtension, audioExtension);

    if (saveFolder.isNull()) ini.remove(Constants::KEY_SaveFolder);
    else ini.setValue(Constants::KEY_SaveFolder, saveFolder);

    if (ffmpegFolder.isNull()) ini.remove(Constants::KEY_FfmpegFolder);
    else ini.setValue(Constants::KEY_FfmpegFolder, ffmpegFolder);

    ini.setValue("geometry", mainWindowGeometry);

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", messageWindowGeometry);
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        ini.setValue(QString("optional%1").arg(i + 1), optionals[i]);
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        ini.setValue(QString("special%1").arg(i + 1), specials[i]);
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        ini.setValue(t.key, titleFormat[i]);

        const auto &f = Constants::FILENAME_ITEMS[i];
        ini.setValue(f.key, fileNameFormat[i]);
    }
    ini.endGroup();
}

/* ============================================================
 * ProgramEntry 読み込み
 * ============================================================ */
void Settings::loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    // checked
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id
    if (!p.keyId.isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // label
    if (!p.keyLabel.isEmpty())
        labels[p.keyLabel] = ini.value(p.keyLabel, p.labelDefault).toString();
}

/* ============================================================
 * ProgramEntry 保存
 * ============================================================ */
void Settings::saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    ini.setValue(p.keyChecked, checked[p.keyChecked]);

    if (!p.keyId.isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!p.keyLabel.isEmpty())
        ini.setValue(p.keyLabel, labels[p.keyLabel]);
}

/* ============================================================
 *  CustomizeDialog API
 * ============================================================ */
QString Settings::getTitleFormat(int index)
{
    return instance().titleFormat[index];
}

QString Settings::getFileNameFormat(int index)
{
    return instance().fileNameFormat[index];
}

void Settings::setTitleFormatValue(int index, const QString &value)
{
    instance().titleFormat[index] = value;
}

void Settings::setFileNameFormatValue(int index, const QString &value)
{
    instance().fileNameFormat[index] = value;
}

/* ============================================================
 *  CheckBox features
 * ============================================================ */
bool Settings::tagSpaceFlag()
{
    return instance().checked[Constants::KEY_TAG_SPACE];
}

bool Settings::nameSpaceFlag()
{
    return instance().checked[Constants::KEY_NAME_SPACE];
}

bool Settings::multiGuiFlag()
{
    return instance().checked[Constants::KEY_MULTI_GUI];
}

bool Settings::kozaSeparationFlag()
{
    return instance().checked[Constants::KEY_KOZA_SEPARATION];
}

void Settings::setTagSpaceFlag(bool flag)
{
    instance().checked[Constants::KEY_TAG_SPACE] = flag;
}

void Settings::setNameSpaceFlag(bool flag)
{
    instance().checked[Constants::KEY_NAME_SPACE] = flag;
}

void Settings::setMultiGuiFlag(bool flag)
{
    instance().checked[Constants::KEY_MULTI_GUI] = flag;
}

void Settings::setKozaSeparationFlag(bool flag)
{
    instance().checked[Constants::KEY_KOZA_SEPARATION] = flag;
}

void Settings::loadMainWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    mainWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMainWindow(const QByteArray &geometry)
{
    mainWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}

void Settings::loadMessageWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMessageWindow(const QByteArray &geometry)
{
    messageWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}











private:
    const Constants::ProgramEntry* findEntryByObjectName(const QString& obj) const;


void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button)
        return;

    const QString obj = button->objectName();

    // ProgramEntry を objectName から直接検索
    const Constants::ProgramEntry* p = findEntryByObjectName(obj);
    if (!p)
        return;

    // Settings を更新
    Settings& s = Settings::instance();
    s.enabled[p->keyEnabled] = checked;

    // タイトルは Settings から取得（ここが最重要）
    QString baseTitle;
    if (!p->keyTitle.isEmpty()) {
        // ユーザーが変更したタイトル
        baseTitle = s.titles[p->keyTitle];
    } else {
        // English など固定タイトル
        baseTitle = p->titleDefault;
    }

    // UI 更新（✓ の付け外しだけ担当）
    updateButtonUI(button, checked, baseTitle);
}


const Constants::ProgramEntry* MainWindow::findEntryByObjectName(const QString& obj) const
{
    auto search = [&](const auto& list) -> const Constants::ProgramEntry* {
        for (const auto& p : list) {
            if (p.objectName == obj)
                return &p;
        }
        return nullptr;
    };

    if (auto* p = search(Constants::EnglishPrograms))  return p;
    if (auto* p = search(Constants::OptionalPrograms)) return p;
    if (auto* p = search(Constants::SpecPrograms))     return p;

    return nullptr;
}



void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ProgramEntry を直接探す
    const Constants::ProgramEntry* p = nullptr;

    auto findEntry = [&](const auto& list) {
        for (const auto& e : list) {
            if (e.objectName == obj) {
                p = &e;
                return;
            }
        }
    };

    findEntry(Constants::EnglishPrograms);
    findEntry(Constants::OptionalPrograms);
    findEntry(Constants::SpecPrograms);

    if (!p) return;  // 見つからない → 何もしない

    // Settings を更新
    Settings::instance().enabled[p->keyEnabled] = checked;

    // UI 更新
    updateButtonUI(button, checked, p->titleDefault);
}



template <typename Container>
void MainWindow::updateProgramButtons(const Container &programs, const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title;
            if (p.keyTitle.isEmpty()) {
                // English
                title = p.titleDefault;
            } else {
                // Optional / Spec
                title = s.titles[p.keyTitle];
            }

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}

template <typename Container>
void updateProgramButtons(const Container &programs, const Settings &s);
auto &s = Settings::instance();
updateProgramButtons(Constants::SpecPrograms, s);


void MainWindow::updateProgramButtons(
    const QVector<ProgramEntry> &programs,
    const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title;

            if (p.keyTitle.isEmpty()) {
                // English
                title = p.titleDefault;
            } else {
                // Optional / Spec
                title = s.titles[p.keyTitle];
            }

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}

updateProgramButtons(Constants::EnglishPrograms, s, true);
updateProgramButtons(Constants::OptionalPrograms, s, false);
updateProgramButtons(Constants::SpecPrograms, s, false);

void MainWindow::updateProgramButtons(
    const QVector<ProgramEntry> &programs,
    const Settings &s,
    bool useDefaultTitle)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title = useDefaultTitle
                ? p.titleDefault
                : s.titles[p.keyTitle];

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}







#include <QToolButton>




void MainWindow::updateButtonUI(QToolButton* btn, bool enabled, const QString& baseTitle)
{
    const QString check = QString::fromUtf8("✓ ");

    btn->blockSignals(true);
    btn->setChecked(enabled);
    btn->blockSignals(false);

    QString text = baseTitle;
    if (enabled) {
        text.prepend(check);
    }
    btn->setText(text);
}

void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // English
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], p.titleDefault);
        }
    }

    // Optional
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Spec
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Flag
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
        }
    }
}

void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ① settings.enabled を更新
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        Settings::instance().enabled[key] = checked;
    }

    // ② UI 更新（✓ の付け外し）
    QString baseTitle = button->text();
    const QString check = QString::fromUtf8("✓ ");

    // ✓ を除去して baseTitle を作る
    if (baseTitle.startsWith(check)) {
        baseTitle.remove(0, check.size());
    }

    updateButtonUI(button, checked, baseTitle);
}







/* ============================================================
 *  CustomizeDialog API
 * ============================================================ */
QString Settings::getTitleFormat(int index)
{
    return instance().titleFormat[index];
}

QString Settings::getFileNameFormat(int index)
{
    return instance().fileNameFormat[index];
}

void Settings::setTitleFormatValue(int index, const QString &value)
{
    instance().titleFormat[index] = value;
}

void Settings::setFileNameFormatValue(int index, const QString &value)
{
    instance().fileNameFormat[index] = value;
}

/* ============================================================
 *  CheckBox flags
 * ============================================================ */
bool Settings::tagSpaceFlag()
{
    return instance().enabled[Constants::KEY_TAG_SPACE];
}

bool Settings::nameSpaceFlag()
{
    return instance().enabled[Constants::KEY_NAME_SPACE];
}

bool Settings::multiGuiFlag()
{
    return instance().enabled[Constants::KEY_MULTI_GUI];
}

bool Settings::kozaSeparationFlag()
{
    return instance().enabled[Constants::KEY_KOZA_SEPARATION];
}

void Settings::setTagSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_TAG_SPACE] = flag;
}

void Settings::setNameSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_NAME_SPACE] = flag;
}

void Settings::setMultiGuiFlag(bool flag)
{
    instance().enabled[Constants::KEY_MULTI_GUI] = flag;
}

void Settings::setKozaSeparationFlag(bool flag)
{
    instance().enabled[Constants::KEY_KOZA_SEPARATION] = flag;
}

void Settings::loadMainWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    mainWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMainWindow(const QByteArray &geometry)
{
    mainWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}

void Settings::loadMessageWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMessageWindow(const QByteArray &geometry)
{
    messageWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}







[100%] Linking CXX executable CaptureStream2
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::formats(QString, QString&, QString&)':
customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x5f): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x8f): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::loadSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x43): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x56): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x9b): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xae): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xea): undefined reference to `Settings::tagSpaceFlag()'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x10c): undefined reference to `Settings::nameSpaceFlag()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::saveSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x5b): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x97): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xc0): undefined reference to `Settings::setTagSpaceFlag(bool)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xf2): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x12e): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x157): undefined reference to `Settings::setNameSpaceFlag(bool)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::saveGui()':
mainwindow.cpp:(.text._ZN10MainWindow7saveGuiEv+0x5a): undefined reference to `Settings::saveMainWindow(QByteArray const&)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeScramble()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeScrambleEv+0x33): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeSettings()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeSettingsEv+0x30): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::download()':
mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x2a): undefined reference to `MainWindow::collectEnglishSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x36): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x42): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x4e): undefined reference to `MainWindow::collectCheckBoxSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/messagewindow.cpp.o: in function `MessageWindow::~MessageWindow()':
messagewindow.cpp:(.text._ZN13MessageWindowD2Ev+0x8b): undefined reference to `Settings::saveMessageWindow(QByteArray const&)'
collect2: error: ld returned 1 exit status
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:457: CaptureStream2] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2





#pragma once
#include <QString>
#include <QStringList>
#include <QMap>
#include "constants.h"
#include "settings.h"

// ===== 実行時に使う番組データ =====
struct RuntimeProgram {
    QString id;      // 実際に使用する番組ID
    QString title;   // 実際に使用するタイトル
    bool enabled;    // 実行対象かどうか
};

class RuntimeConfig
{
public:
    RuntimeConfig();

    // Settings → RuntimeConfig へコピー
    void applySettings(const Settings &s);

    // CLI オプションで上書き
    void applyCommandLine(const QMap<QString, QString> &opts);

    // ===== 実行時の最終値 =====
    RuntimeProgram english[Constants::EnglishCount];
    RuntimeProgram optional[Constants::OptionalCount];
    RuntimeProgram spec[Constants::SpecCount];
    bool checkBox[Constants::FlagCount];

    // ===== その他設定 =====
    QString saveFolder;
    QString audioExtension;

    // 最新番組一覧（ProgramEntry に変更）
    QMap<QString, Constants::ProgramEntry> latestProgramMap;

    // name_map / id_map / thumbnail_map
    QMap<QString, QString> id_map;
    QMap<QString, QString> name_map;
    QMap<QString, QString> thumbnail_map;
};


#include "runtimeconfig.h"
#include "constants.h"

RuntimeConfig::RuntimeConfig()
{
}

void RuntimeConfig::applySettings(const Settings &s)
{
    // ===== English =====
    for (int i = 0; i < Constants::EnglishCount; i++) {
        const auto &p = Constants::EnglishPrograms[i];

        english[i].enabled = s.enabled[p.keyEnabled];
        english[i].id      = p.idDefault;       // English は固定
        english[i].title   = p.titleDefault;    // English は固定
    }

    // ===== Optional =====
    for (int i = 0; i < Constants::OptionalCount; i++) {
        const auto &p = Constants::OptionalPrograms[i];

        optional[i].enabled = s.enabled[p.keyEnabled];
        optional[i].id      = s.ids[p.keyId];
        optional[i].title   = s.titles[p.keyTitle];
    }

    // ===== Spec =====
    for (int i = 0; i < Constants::SpecCount; i++) {
        const auto &p = Constants::SpecPrograms[i];

        spec[i].enabled = s.enabled[p.keyEnabled];
        spec[i].id      = s.ids[p.keyId];
        spec[i].title   = s.titles[p.keyTitle];
    }

    // ===== Flag（チェックボックス）=====
    for (int i = 0; i < Constants::FlagCount; i++) {
        const auto &p = Constants::FlagSettings[i];
        checkBox[i] = s.enabled[p.keyEnabled];
    }

    // ===== その他設定 =====
    saveFolder     = s.saveFolder;
    audioExtension = s.audioExtension;
}

void RuntimeConfig::applyCommandLine(const QMap<QString, QString> &opts)
{
    // --save-folder
    if (opts.contains("save-folder"))
        saveFolder = opts["save-folder"];

    // --audio-ext
    if (opts.contains("audio-ext"))
        audioExtension = opts["audio-ext"];

    // --enable=xxx
    if (opts.contains("enable")) {
        QString key = opts["enable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = true;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = true;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = true;
    }

    // --disable=xxx
    if (opts.contains("disable")) {
        QString key = opts["disable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = false;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = false;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = false;
    }
}








#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class ScrambleDialog;
}

class ScrambleDialog : public QDialog {
    Q_OBJECT

public:
    explicit ScrambleDialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~ScrambleDialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::ScrambleDialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateOptional(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};


#include "scrambledialog.h"
#include "ui_scrambledialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

ScrambleDialog::ScrambleDialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::ScrambleDialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4,
              ui->edit5, ui->edit6, ui->edit7, ui->edit8 };

    // ===== OptionalPrograms の ID を Settings から復元 =====
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++) {
        const auto &p = Constants::OptionalPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== フラグ復元 =====
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

ScrambleDialog::~ScrambleDialog()
{
    delete ui;
}

void ScrambleDialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
}

QString ScrambleDialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = OPT_PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.optionals;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit *edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void ScrambleDialog::accept()
{
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++)
        updateOptional(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void ScrambleDialog::updateLabels()
{
    std::array<QLabel*, Constants::OPT_PRESET_SIZE> labels = {
        ui->label_2, ui->label_3, ui->label_4, ui->label_5,
        ui->label_6, ui->label_7, ui->label_8, ui->label_9
    };

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void ScrambleDialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {

            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void ScrambleDialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3] + "\n" +
        "５：" + titles[4] + "\n" +
        "６：" + titles[5] + "\n" +
        "７：" + titles[6] + "\n" +
        "８：" + titles[7];

    if (QMessageBox::question(this, tr("任意番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
            settings.optionals[i] = edits[i]->text();
    }
}

QString ScrambleDialog::updateOptional(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = OptionalPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}









#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class Settingsdialog;
}

class Settingsdialog : public QDialog {
    Q_OBJECT

public:
    explicit Settingsdialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~Settingsdialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::Settingsdialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateSpecial(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};



#include "settingsdialog.h"
#include "ui_settingsdialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

Settingsdialog::Settingsdialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::Settingsdialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4 };

    // ===== 特番（SpecPrograms）を Settings から復元 =====
    for (int i = 0; i < Constants::PRESET_SIZE; i++) {
        const auto &p = Constants::SpecPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== チェックボックスフラグ =====
    ui->checkBox->setChecked(settings.enabled[Constants::KEY_MULTI_GUI]);
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

Settingsdialog::~Settingsdialog()
{
    delete ui;
}

void Settingsdialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
    settings.enabled[Constants::KEY_MULTI_GUI] = ui->checkBox->isChecked();
}

QString Settingsdialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.specials;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit* edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void Settingsdialog::accept()
{
    for (int i = 0; i < Constants::PRESET_SIZE; i++)
        updateSpecial(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void Settingsdialog::updateLabels()
{
    std::array<QLabel*, Constants::PRESET_SIZE> labels =
        { ui->label_2, ui->label_3, ui->label_4, ui->label_5 };

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void Settingsdialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {
            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void Settingsdialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3];

    if (QMessageBox::question(this, tr("特別番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::PRESET_SIZE; ++i)
            settings.specials[i] = edits[i]->text();
    }
}

QString Settingsdialog::updateSpecial(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = SpecPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}






void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry 復元
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // ===== English =====
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);
            btn->setText(p.titleDefault);   // 固定タイトル
        }
    }

    // ===== Optional =====
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Spec =====
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Flag（チェックボックス）=====
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
            // ラベルは UI 側の固定値を使うので setText は不要
        }
    }
}

void MainWindow::saveGui()
{
    auto &s = Settings::instance();

    // geometry 保存
    s.saveMainWindow(saveGeometry());

    // enabled の書き戻し
    for (const auto &p : Constants::EnglishPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::OptionalPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::SpecPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::FlagSettings) {
        if (!p.objectName.isEmpty()) {
            if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = cb->isChecked();
            }
        }
    }

    // 最後に settings.ini へ保存
    s.save();
}





// Settings.h

#pragma once
#include <QString>
#include <QSettings>
#include <QMap>
#include <QVector>
#include <QByteArray>
#include "constants.h"

class Settings
{
public:
    static Settings& instance();

    void load();
    void save();

    // ===== MainWindow / MessageWindow =====
    void loadMainWindow();
    void saveMainWindow(const QByteArray &geometry);

    void loadMessageWindow();
    void saveMessageWindow(const QByteArray &geometry);

    // ===== 基本設定 =====
    QString audioExtension;
    QString ffmpegFolder;
    QString saveFolder;

    // ===== ProgramEntry の値（enabled / id / title）=====
    // keyEnabled → enabled
    QMap<QString, bool> enabled;

    // keyId → id
    QMap<QString, QString> ids;

    // keyTitle → title
    QMap<QString, QString> titles;

    // ===== optional / spec のプリセット =====
    std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
    std::array<QString, Constants::PRESET_SIZE> specials;

    // ===== geometry =====
    QByteArray mainWindowGeometry;
    QByteArray messageWindowGeometry;

    // ===== CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    static QString getTitleFormat(int index);
    static QString getFileNameFormat(int index);

    static void setTitleFormatValue(int index, const QString &value);
    static void setFileNameFormatValue(int index, const QString &value);

    // ===== CheckBox flags =====
    static bool tagSpaceFlag();
    static bool nameSpaceFlag();
    static bool multiGuiFlag();
    static bool kozaSeparationFlag();

    static void setTagSpaceFlag(bool flag);
    static void setNameSpaceFlag(bool flag);
    static void setMultiGuiFlag(bool flag);
    static void setKozaSeparationFlag(bool flag);

private:
    Settings();
    Settings(const Settings&) = delete;
    Settings& operator=(const Settings&) = delete;

    // 内部ヘルパー
    void loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
    void saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
};


//settings.cpp
#include "settings.h"
#include <QSettings>

Settings::Settings()
{
}

Settings& Settings::instance()
{
    static Settings inst;
    return inst;
}

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     loadProgramEntry(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}

void Settings::save()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて保存
    for (const auto &p : Constants::EnglishPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     saveProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     saveProgramEntry(p, ini);

    ini.setValue(Constants::KEY_AudioExtension, audioExtension);

    if (saveFolder.isNull()) ini.remove(Constants::KEY_SaveFolder);
    else ini.setValue(Constants::KEY_SaveFolder, saveFolder);

    if (ffmpegFolder.isNull()) ini.remove(Constants::KEY_FfmpegFolder);
    else ini.setValue(Constants::KEY_FfmpegFolder, ffmpegFolder);

    ini.setValue("geometry", mainWindowGeometry);

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", messageWindowGeometry);
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        ini.setValue(QString("optional%1").arg(i + 1), optionals[i]);
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        ini.setValue(QString("special%1").arg(i + 1), specials[i]);
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        ini.setValue(t.key, titleFormat[i]);

        const auto &f = Constants::FILENAME_ITEMS[i];
        ini.setValue(f.key, fileNameFormat[i]);
    }
    ini.endGroup();
}

/* ============================================================
 * ProgramEntry 読み込み
 * ============================================================ */
void Settings::loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    // enabled
    enabled[p.keyEnabled] =
        ini.value(p.keyEnabled, p.enabledDefault).toBool();

    // id
    if (!p.keyId.isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // title
    if (!p.keyTitle.isEmpty())
        titles[p.keyTitle] = ini.value(p.keyTitle, p.titleDefault).toString();
}

/* ============================================================
 * ProgramEntry 保存
 * ============================================================ */
void Settings::saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    ini.setValue(p.keyEnabled, enabled[p.keyEnabled]);

    if (!p.keyId.isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!p.keyTitle.isEmpty())
        ini.setValue(p.keyTitle, titles[p.keyTitle]);
}






class Settings {
public:
    static Settings& instance();

    // 既存のマップ
    QMap<QString, bool> englishEnabled;
    QMap<QString, bool> optionalEnabled;
    QMap<QString, bool> specEnabled;
    QMap<QString, bool> checkBoxEnabled;

    // ★ 追加：横断 enabled キャッシュ（INI に保存しない）
    QMap<QString, bool> enabled;

    void buildUnifiedEnabled();   // load() の後に呼ぶ
    void syncEnabledBack();       // save() の前に呼ぶ

    // ...
};


void Settings::buildUnifiedEnabled()
{
    enabled.clear();

    // English
    for (const auto& p : Constants::EnglishPrograms) {
        enabled[p.key] = englishEnabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        enabled[p.keyEnabled] = optionalEnabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        enabled[p.keyEnabled] = specEnabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        enabled[c.keyEnabled] = checkBoxEnabled[c.keyEnabled];
    }
}


void Settings::syncEnabledBack()
{
    // English
    for (const auto& p : Constants::EnglishPrograms) {
        englishEnabled[p.key] = enabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        optionalEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        specEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        checkBoxEnabled[c.keyEnabled] = enabled[c.keyEnabled];
    }
}



buildUnifiedEnabled();


syncEnabledBack();


QMap<QString, QString> objectToKey;


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    using namespace Constants;

    // English
    for (const auto& p : EnglishPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.key;
    }

    // Optional
    for (const auto& p : OptionalPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // Spec
    for (const auto& p : SpecPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // CheckBox
    for (const auto& c : CheckBoxSettings) {
        if (!c.objectName.isEmpty())
            objectToKey[c.objectName] = c.keyEnabled;
    }
}


void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ★ 横断 enabled に書き込むだけ
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        settings.enabled[key] = checked;
    }

    // UI のチェックマーク処理
    QString text = button->text();
    const QString check = QString::fromUtf8("✓ ");

    if (text.startsWith(check))
        text.remove(0, check.size());

    if (checked)
        text.prepend(check);

    button->setText(text);
}
