[ 38%] Building CXX object CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o
/home/kazuo/cs/CaptureStream2/mainwindow.cpp: In member function ‘void MainWindow::ffmpegFolderDialog()’:
/home/kazuo/cs/CaptureStream2/mainwindow.cpp:851:60: error: ‘QString Settings::autoDetectFfmpeg()’ is private within this context
  851 |         QString dir = Settings::instance().autoDetectFfmpeg();
      |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~
In file included from /home/kazuo/cs/CaptureStream2/mainwindow.h:40,
                 from /home/kazuo/cs/CaptureStream2/mainwindow.cpp:24:
/home/kazuo/cs/CaptureStream2/settings.h:96:13: note: declared private here
   96 |     QString autoDetectFfmpeg();   // OS別探索
      |             ^~~~~~~~~~~~~~~~
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:155: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2



QString ffmpegFolder;

private:
    void initDefaultFfmpegFolder();
    QString autoDetectFfmpeg();   // OS別探索



settings cpp

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    ini.endGroup();

    // ===== 初回起動時の OS 別初期化 =====
    initDefaultFfmpegFolder();
}

void Settings::initDefaultFfmpegFolder()
{
    if (!ffmpegFolder.isEmpty())
        return;  // すでに設定済み

    // OS別に自動探索
    QString detected = autoDetectFfmpeg();
    if (!detected.isEmpty()) {
        ffmpegFolder = detected;
        return;
    }

    // 見つからなければ空のまま（MainWindow がダイアログを出す）
    ffmpegFolder.clear();
}

QString Settings::autoDetectFfmpeg()
{
    QProcess process;
    QString ffmpegPath;

#ifdef Q_OS_WIN
    process.start("cmd.exe", QStringList() << "/c" << "where" << "ffmpeg");
#else
    process.start("which", QStringList() << "ffmpeg");
#endif
    process.waitForFinished();

    ffmpegPath = QString::fromUtf8(process.readAllStandardOutput())
                     .split("\n").first().trimmed();

    if (!QFileInfo::exists(ffmpegPath)) {
#ifdef Q_OS_MAC
        QString arch = QSysInfo::buildCpuArchitecture();
        if (arch == "x86_64") {
            ffmpegPath = "/usr/local/bin/ffmpeg";
        } else if (arch == "arm64") {
            ffmpegPath = "/opt/homebrew/bin/ffmpeg";
            if (!QFile::exists(ffmpegPath))
                ffmpegPath = "/usr/local/bin/ffmpeg";
        }
#elif defined(Q_OS_LINUX)
        ffmpegPath = "/usr/bin/ffmpeg";
#elif defined(Q_OS_WIN)
        ffmpegPath = "C:\\Program Files\\ffmpeg\\bin\\ffmpeg.exe";
        if (!QFile::exists(ffmpegPath))
            ffmpegPath = "C:\\ffmpeg\\bin\\ffmpeg.exe";
#endif
    }

    if (QFile::exists(ffmpegPath))
        return QFileInfo(ffmpegPath).absolutePath();

    return QString();
}

mainwindowcっp
void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // ffmpeg が未設定なら設定ダイアログを開く
    if (s.ffmpegFolder.isEmpty()) {
        ffmpegFolderDialog();
    }

    // その他の復元処理…
}


void MainWindow::ffmpegFolderDialog()
{
    auto &s = Settings::instance();

    QMessageBox msgBox(this);
    QString message = QString::fromUtf8("ffmpegがあるフォルダを設定しますか？\n現在設定：\n") 
                      + s.ffmpegFolder;
    msgBox.setIcon(QMessageBox::Question);
    msgBox.setWindowTitle(tr("ffmpegがあるフォルダ設定"));
    msgBox.setText(message);

    QPushButton* setButton = msgBox.addButton(tr("設定する"), QMessageBox::ActionRole);
    QPushButton* searchButton = msgBox.addButton(tr("検索"), QMessageBox::ActionRole);
    QPushButton* bundledButton = msgBox.addButton(tr("同梱"), QMessageBox::ActionRole);
    QPushButton* resetButton = msgBox.addButton(tr("初期値に戻す"), QMessageBox::ActionRole);
    msgBox.setStandardButtons(QMessageBox::Cancel);

    if (msgBox.exec() == QMessageBox::Cancel)
        return;

    QPushButton* clicked = qobject_cast<QPushButton*>(msgBox.clickedButton());

    if (clicked == setButton) {

        QString dir = QFileDialog::getExistingDirectory(
            this, tr("ffmpegがあるフォルダを指定してください"),
            s.ffmpegFolder,
            QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

        if (!dir.isEmpty())
            s.ffmpegFolder = dir + QDir::separator();

    } else if (clicked == resetButton) {

        s.ffmpegFolder = Utility::applicationBundlePath();

    } else if (clicked == searchButton) {

        QString dir = Settings::instance().autoDetectFfmpeg();
        if (!dir.isEmpty()) {
            QString msg = QString::fromUtf8("ffmpegがある下記フォルダを見つけました。\n設定しますか？\n\n") + dir;
            if (QMessageBox::Yes == QMessageBox::question(this, tr("ffmpegフォルダ設定"), msg))
                s.ffmpegFolder = dir + QDir::separator();
        }

    } else if (clicked == bundledButton) {

        QString dir = Utility::applicationBundlePath();
        QString msg = QString::fromUtf8("同梱のffmpegを使用します。\n設定しますか？\n\n") + dir;
        if (QMessageBox::Yes == QMessageBox::question(this, tr("同梱ffmpeg設定"), msg))
            s.ffmpegFolder = dir + QDir::separator();
    }
}

private:
    bool isValidFfmpegFolder(const QString& folder) const;
    bool canExecuteFfmpeg(const QString& ffmpegPath) const;


bool Settings::isValidFfmpegFolder(const QString& folder) const
{
    if (folder.isEmpty())
        return false;

    QDir dir(folder);
    if (!dir.exists())
        return false;

#ifdef Q_OS_WIN
    QString exe = dir.filePath("ffmpeg.exe");
#else
    QString exe = dir.filePath("ffmpeg");
#endif

    if (!QFileInfo::exists(exe))
        return false;

    return canExecuteFfmpeg(exe);
}

bool Settings::canExecuteFfmpeg(const QString& ffmpegPath) const
{
    QProcess p;
    p.start(ffmpegPath, {"-version"});
    if (!p.waitForFinished(1500))  // タイムアウト短めでOK
        return false;

    return (p.exitStatus() == QProcess::NormalExit);
}


void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    ffmpegFolder = ini.value(Constants::KEY_FfmpegFolder).toString();

    ini.endGroup();

    // OS別初期値設定（未設定の場合のみ）
    initDefaultFfmpegFolder();

    // 妥当性確認（壊れたパスなら空にする）
    if (!isValidFfmpegFolder(ffmpegFolder)) {
        ffmpegFolder.clear();
    }
}





// audio_extension
if (auto combo = findChild<QComboBox*>("comboBox_extension")) {
    int index = combo->findText(s.audioExtension);
    if (index >= 0)
        combo->setCurrentIndex(index);
}

// saveFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_saveFolder"))
    edit->setText(s.saveFolder);

// ffmpegFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_ffmpegFolder"))
    edit->setText(s.ffmpegFolder);

// audio_extension
if (auto combo = findChild<QComboBox*>("comboBox_extension"))
    s.audioExtension = combo->currentText();

// saveFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_saveFolder"))
    s.saveFolder = edit->text();

// ffmpegFolder
if (auto edit = findChild<QLineEdit*>("lineEdit_ffmpegFolder"))
    s.ffmpegFolder = edit->text();




void MainWindow::updateButtonUI(QToolButton* btn, bool checked, const QString& label)
{
    btn->blockSignals(true);
    btn->setChecked(checked);
    btn->blockSignals(false);

    if (label.isEmpty())
        return;

    static const QString mark = QString::fromUtf8("✓ ");

    btn->setText(checked ? mark + label : label);
}

void MainWindow::saveGui()
{
    auto &s = Settings::instance();

    // geometry 保存
    s.saveMainWindow(saveGeometry());

    // English / Optional / Spec / Feature をすべて保存
    saveProgramButtons(Constants::EnglishPrograms, s);
    saveProgramButtons(Constants::OptionalPrograms, s);
    saveProgramButtons(Constants::SpecPrograms, s);
    saveProgramButtons(Constants::FeatureSettings, s);

    // 最後に settings.ini へ保存
    s.save();
}

template <typename Container>
void MainWindow::saveProgramButtons(const Container &programs, Settings &s)
{
    for (const auto &p : programs) {
        if (p.objectName.isEmpty())
            continue;

        // QAbstractButton で統一（QToolButton も QCheckBox も継承）
        if (auto btn = findChild<QAbstractButton*>(p.objectName)) {
            s.checked[p.keyChecked] = btn->isChecked();
        }
    }
}



void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry 復元
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // ===== English =====
    updateProgramButtons(Constants::EnglishPrograms, s);
     // ===== Optional =====   
    updateProgramButtons(Constants::OptionalPrograms, s);
    // ===== Spec =====
    updateProgramButtons(Constants::SpecPrograms, s);
    // ===== Feature（チェックボックス）=====
    updateProgramButtons(Constants::FeatureSettings, s);
}

template <typename Container>
void MainWindow::updateProgramButtons(const Container &programs, const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString label;
            if (p.keyLabel.isEmpty()) {
                // English
                label = p.labelDefault;
            } else {
                // Optional / Spec
                label = s.labels[p.keyLabel];
            }

            updateButtonUI(btn, s.checked[p.keyChecked], label);
        }
    }
}

void MainWindow::updateButtonUI(QToolButton* btn, bool checked, const QString& baseLabel)
{
    const QString check = QString::fromUtf8("✓ ");

    btn->blockSignals(true);
    btn->setChecked(checked);
    btn->blockSignals(false);

    if (baseLabel.isEmpty()) return;
    QString text = baseLabel;
    if (checked) {		
        text.prepend(check);	            // 状態に応じて「✓」付与
    }
    btn->setText(text);
}






settings.h

#pragma once
#include <QString>
#include <QSettings>
#include <QMap>
#include <QVector>
#include <QByteArray>
#include "constants.h"

class Settings
{
public:
    static Settings& instance();

    void load();
    void save();

    // ===== MainWindow / MessageWindow =====
    void loadMainWindow();
    void saveMainWindow(const QByteArray &geometry);

    void loadMessageWindow();
    void saveMessageWindow(const QByteArray &geometry);

    // ===== 基本設定 =====
    QString audioExtension;
    QString ffmpegFolder;
    QString saveFolder;

    // ===== ProgramEntry の値（checked / id / label）=====
    // keyChecked → checked
    QMap<QString, bool> checked;

    // keyId → id
    QMap<QString, QString> ids;

    // keyLabel → label
    QMap<QString, QString> labels;

    // ===== optional / spec のプリセット =====
    std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
    std::array<QString, Constants::PRESET_SIZE> specials;

    // ===== geometry =====
    QByteArray mainWindowGeometry;
    QByteArray messageWindowGeometry;

    // ===== CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    static QString getTitleFormat(int index);
    static QString getFileNameFormat(int index);

    static void setTitleFormatValue(int index, const QString &value);
    static void setFileNameFormatValue(int index, const QString &value);

    // ===== CheckBox features =====
    static bool tagSpaceFlag();
    static bool nameSpaceFlag();
    static bool multiGuiFlag();
    static bool kozaSeparationFlag();

    static void setTagSpaceFlag(bool flag);
    static void setNameSpaceFlag(bool flag);
    static void setMultiGuiFlag(bool flag);
    static void setKozaSeparationFlag(bool flag);

private:
    Settings();
    Settings(const Settings&) = delete;
    Settings& operator=(const Settings&) = delete;

    // 内部ヘルパー
    void loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
    void saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
};



settings.cpp

#include "settings.h"
#include <QSettings>

Settings::Settings()
{
}

Settings& Settings::instance()
{
    static Settings inst;
    return inst;
}

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramEntry(p, ini);
    for (const auto &p : Constants::FeatureSettings)     loadProgramEntry(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}

void Settings::save()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Feature をすべて保存
    for (const auto &p : Constants::EnglishPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     saveProgramEntry(p, ini);
    for (const auto &p : Constants::FeatureSettings)     saveProgramEntry(p, ini);

    ini.setValue(Constants::KEY_AudioExtension, audioExtension);

    if (saveFolder.isNull()) ini.remove(Constants::KEY_SaveFolder);
    else ini.setValue(Constants::KEY_SaveFolder, saveFolder);

    if (ffmpegFolder.isNull()) ini.remove(Constants::KEY_FfmpegFolder);
    else ini.setValue(Constants::KEY_FfmpegFolder, ffmpegFolder);

    ini.setValue("geometry", mainWindowGeometry);

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", messageWindowGeometry);
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        ini.setValue(QString("optional%1").arg(i + 1), optionals[i]);
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        ini.setValue(QString("special%1").arg(i + 1), specials[i]);
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        ini.setValue(t.key, titleFormat[i]);

        const auto &f = Constants::FILENAME_ITEMS[i];
        ini.setValue(f.key, fileNameFormat[i]);
    }
    ini.endGroup();
}

/* ============================================================
 * ProgramEntry 読み込み
 * ============================================================ */
void Settings::loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    // checked
    checked[p.keyChecked] =
        ini.value(p.keyChecked, p.checkedDefault).toBool();

    // id
    if (!p.keyId.isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // label
    if (!p.keyLabel.isEmpty())
        labels[p.keyLabel] = ini.value(p.keyLabel, p.labelDefault).toString();
}

/* ============================================================
 * ProgramEntry 保存
 * ============================================================ */
void Settings::saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    ini.setValue(p.keyChecked, checked[p.keyChecked]);

    if (!p.keyId.isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!p.keyLabel.isEmpty())
        ini.setValue(p.keyLabel, labels[p.keyLabel]);
}

/* ============================================================
 *  CustomizeDialog API
 * ============================================================ */
QString Settings::getTitleFormat(int index)
{
    return instance().titleFormat[index];
}

QString Settings::getFileNameFormat(int index)
{
    return instance().fileNameFormat[index];
}

void Settings::setTitleFormatValue(int index, const QString &value)
{
    instance().titleFormat[index] = value;
}

void Settings::setFileNameFormatValue(int index, const QString &value)
{
    instance().fileNameFormat[index] = value;
}

/* ============================================================
 *  CheckBox features
 * ============================================================ */
bool Settings::tagSpaceFlag()
{
    return instance().checked[Constants::KEY_TAG_SPACE];
}

bool Settings::nameSpaceFlag()
{
    return instance().checked[Constants::KEY_NAME_SPACE];
}

bool Settings::multiGuiFlag()
{
    return instance().checked[Constants::KEY_MULTI_GUI];
}

bool Settings::kozaSeparationFlag()
{
    return instance().checked[Constants::KEY_KOZA_SEPARATION];
}

void Settings::setTagSpaceFlag(bool flag)
{
    instance().checked[Constants::KEY_TAG_SPACE] = flag;
}

void Settings::setNameSpaceFlag(bool flag)
{
    instance().checked[Constants::KEY_NAME_SPACE] = flag;
}

void Settings::setMultiGuiFlag(bool flag)
{
    instance().checked[Constants::KEY_MULTI_GUI] = flag;
}

void Settings::setKozaSeparationFlag(bool flag)
{
    instance().checked[Constants::KEY_KOZA_SEPARATION] = flag;
}

void Settings::loadMainWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    mainWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMainWindow(const QByteArray &geometry)
{
    mainWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}

void Settings::loadMessageWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMessageWindow(const QByteArray &geometry)
{
    messageWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}











private:
    const Constants::ProgramEntry* findEntryByObjectName(const QString& obj) const;


void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button)
        return;

    const QString obj = button->objectName();

    // ProgramEntry を objectName から直接検索
    const Constants::ProgramEntry* p = findEntryByObjectName(obj);
    if (!p)
        return;

    // Settings を更新
    Settings& s = Settings::instance();
    s.enabled[p->keyEnabled] = checked;

    // タイトルは Settings から取得（ここが最重要）
    QString baseTitle;
    if (!p->keyTitle.isEmpty()) {
        // ユーザーが変更したタイトル
        baseTitle = s.titles[p->keyTitle];
    } else {
        // English など固定タイトル
        baseTitle = p->titleDefault;
    }

    // UI 更新（✓ の付け外しだけ担当）
    updateButtonUI(button, checked, baseTitle);
}


const Constants::ProgramEntry* MainWindow::findEntryByObjectName(const QString& obj) const
{
    auto search = [&](const auto& list) -> const Constants::ProgramEntry* {
        for (const auto& p : list) {
            if (p.objectName == obj)
                return &p;
        }
        return nullptr;
    };

    if (auto* p = search(Constants::EnglishPrograms))  return p;
    if (auto* p = search(Constants::OptionalPrograms)) return p;
    if (auto* p = search(Constants::SpecPrograms))     return p;

    return nullptr;
}



void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ProgramEntry を直接探す
    const Constants::ProgramEntry* p = nullptr;

    auto findEntry = [&](const auto& list) {
        for (const auto& e : list) {
            if (e.objectName == obj) {
                p = &e;
                return;
            }
        }
    };

    findEntry(Constants::EnglishPrograms);
    findEntry(Constants::OptionalPrograms);
    findEntry(Constants::SpecPrograms);

    if (!p) return;  // 見つからない → 何もしない

    // Settings を更新
    Settings::instance().enabled[p->keyEnabled] = checked;

    // UI 更新
    updateButtonUI(button, checked, p->titleDefault);
}



template <typename Container>
void MainWindow::updateProgramButtons(const Container &programs, const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title;
            if (p.keyTitle.isEmpty()) {
                // English
                title = p.titleDefault;
            } else {
                // Optional / Spec
                title = s.titles[p.keyTitle];
            }

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}

template <typename Container>
void updateProgramButtons(const Container &programs, const Settings &s);
auto &s = Settings::instance();
updateProgramButtons(Constants::SpecPrograms, s);


void MainWindow::updateProgramButtons(
    const QVector<ProgramEntry> &programs,
    const Settings &s)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title;

            if (p.keyTitle.isEmpty()) {
                // English
                title = p.titleDefault;
            } else {
                // Optional / Spec
                title = s.titles[p.keyTitle];
            }

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}

updateProgramButtons(Constants::EnglishPrograms, s, true);
updateProgramButtons(Constants::OptionalPrograms, s, false);
updateProgramButtons(Constants::SpecPrograms, s, false);

void MainWindow::updateProgramButtons(
    const QVector<ProgramEntry> &programs,
    const Settings &s,
    bool useDefaultTitle)
{
    for (const auto &p : programs) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {

            QString title = useDefaultTitle
                ? p.titleDefault
                : s.titles[p.keyTitle];

            updateButtonUI(btn, s.enabled[p.keyEnabled], title);
        }
    }
}







#include <QToolButton>




void MainWindow::updateButtonUI(QToolButton* btn, bool enabled, const QString& baseTitle)
{
    const QString check = QString::fromUtf8("✓ ");

    btn->blockSignals(true);
    btn->setChecked(enabled);
    btn->blockSignals(false);

    QString text = baseTitle;
    if (enabled) {
        text.prepend(check);
    }
    btn->setText(text);
}

void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // English
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], p.titleDefault);
        }
    }

    // Optional
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Spec
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            updateButtonUI(btn, s.enabled[p.keyEnabled], s.titles[p.keyTitle]);
        }
    }

    // Flag
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
        }
    }
}

void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ① settings.enabled を更新
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        Settings::instance().enabled[key] = checked;
    }

    // ② UI 更新（✓ の付け外し）
    QString baseTitle = button->text();
    const QString check = QString::fromUtf8("✓ ");

    // ✓ を除去して baseTitle を作る
    if (baseTitle.startsWith(check)) {
        baseTitle.remove(0, check.size());
    }

    updateButtonUI(button, checked, baseTitle);
}







/* ============================================================
 *  CustomizeDialog API
 * ============================================================ */
QString Settings::getTitleFormat(int index)
{
    return instance().titleFormat[index];
}

QString Settings::getFileNameFormat(int index)
{
    return instance().fileNameFormat[index];
}

void Settings::setTitleFormatValue(int index, const QString &value)
{
    instance().titleFormat[index] = value;
}

void Settings::setFileNameFormatValue(int index, const QString &value)
{
    instance().fileNameFormat[index] = value;
}

/* ============================================================
 *  CheckBox flags
 * ============================================================ */
bool Settings::tagSpaceFlag()
{
    return instance().enabled[Constants::KEY_TAG_SPACE];
}

bool Settings::nameSpaceFlag()
{
    return instance().enabled[Constants::KEY_NAME_SPACE];
}

bool Settings::multiGuiFlag()
{
    return instance().enabled[Constants::KEY_MULTI_GUI];
}

bool Settings::kozaSeparationFlag()
{
    return instance().enabled[Constants::KEY_KOZA_SEPARATION];
}

void Settings::setTagSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_TAG_SPACE] = flag;
}

void Settings::setNameSpaceFlag(bool flag)
{
    instance().enabled[Constants::KEY_NAME_SPACE] = flag;
}

void Settings::setMultiGuiFlag(bool flag)
{
    instance().enabled[Constants::KEY_MULTI_GUI] = flag;
}

void Settings::setKozaSeparationFlag(bool flag)
{
    instance().enabled[Constants::KEY_KOZA_SEPARATION] = flag;
}

void Settings::loadMainWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    mainWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMainWindow(const QByteArray &geometry)
{
    mainWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}

void Settings::loadMessageWindow()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();
}

void Settings::saveMessageWindow(const QByteArray &geometry)
{
    messageWindowGeometry = geometry;
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", geometry);
    ini.endGroup();
}







[100%] Linking CXX executable CaptureStream2
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::formats(QString, QString&, QString&)':
customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x5f): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog7formatsE7QStringRS0_S1_+0x8f): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::loadSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x43): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x56): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x9b): undefined reference to `Settings::getTitleFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xae): undefined reference to `Settings::getFileNameFormat(int)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0xea): undefined reference to `Settings::tagSpaceFlag()'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12loadSettingsEv+0x10c): undefined reference to `Settings::nameSpaceFlag()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/customizedialog.cpp.o: in function `CustomizeDialog::saveSettings()':
customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x5b): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x97): undefined reference to `Settings::setTitleFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xc0): undefined reference to `Settings::setTagSpaceFlag(bool)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0xf2): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x12e): undefined reference to `Settings::setFileNameFormatValue(int, QString const&)'
/usr/bin/ld: customizedialog.cpp:(.text._ZN15CustomizeDialog12saveSettingsEv+0x157): undefined reference to `Settings::setNameSpaceFlag(bool)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::saveGui()':
mainwindow.cpp:(.text._ZN10MainWindow7saveGuiEv+0x5a): undefined reference to `Settings::saveMainWindow(QByteArray const&)'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeScramble()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeScrambleEv+0x33): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::customizeSettings()':
mainwindow.cpp:(.text._ZN10MainWindow17customizeSettingsEv+0x30): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/mainwindow.cpp.o: in function `MainWindow::download()':
mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x2a): undefined reference to `MainWindow::collectEnglishSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x36): undefined reference to `MainWindow::collectOptionalSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x42): undefined reference to `MainWindow::collectSpecSettings()'
/usr/bin/ld: mainwindow.cpp:(.text._ZN10MainWindow8downloadEv+0x4e): undefined reference to `MainWindow::collectCheckBoxSettings()'
/usr/bin/ld: CMakeFiles/CaptureStream2.dir/messagewindow.cpp.o: in function `MessageWindow::~MessageWindow()':
messagewindow.cpp:(.text._ZN13MessageWindowD2Ev+0x8b): undefined reference to `Settings::saveMessageWindow(QByteArray const&)'
collect2: error: ld returned 1 exit status
make[2]: *** [CMakeFiles/CaptureStream2.dir/build.make:457: CaptureStream2] エラー 1
make[1]: *** [CMakeFiles/Makefile2:84: CMakeFiles/CaptureStream2.dir/all] エラー 2
make: *** [Makefile:91: all] エラー 2





#pragma once
#include <QString>
#include <QStringList>
#include <QMap>
#include "constants.h"
#include "settings.h"

// ===== 実行時に使う番組データ =====
struct RuntimeProgram {
    QString id;      // 実際に使用する番組ID
    QString title;   // 実際に使用するタイトル
    bool enabled;    // 実行対象かどうか
};

class RuntimeConfig
{
public:
    RuntimeConfig();

    // Settings → RuntimeConfig へコピー
    void applySettings(const Settings &s);

    // CLI オプションで上書き
    void applyCommandLine(const QMap<QString, QString> &opts);

    // ===== 実行時の最終値 =====
    RuntimeProgram english[Constants::EnglishCount];
    RuntimeProgram optional[Constants::OptionalCount];
    RuntimeProgram spec[Constants::SpecCount];
    bool checkBox[Constants::FlagCount];

    // ===== その他設定 =====
    QString saveFolder;
    QString audioExtension;

    // 最新番組一覧（ProgramEntry に変更）
    QMap<QString, Constants::ProgramEntry> latestProgramMap;

    // name_map / id_map / thumbnail_map
    QMap<QString, QString> id_map;
    QMap<QString, QString> name_map;
    QMap<QString, QString> thumbnail_map;
};


#include "runtimeconfig.h"
#include "constants.h"

RuntimeConfig::RuntimeConfig()
{
}

void RuntimeConfig::applySettings(const Settings &s)
{
    // ===== English =====
    for (int i = 0; i < Constants::EnglishCount; i++) {
        const auto &p = Constants::EnglishPrograms[i];

        english[i].enabled = s.enabled[p.keyEnabled];
        english[i].id      = p.idDefault;       // English は固定
        english[i].title   = p.titleDefault;    // English は固定
    }

    // ===== Optional =====
    for (int i = 0; i < Constants::OptionalCount; i++) {
        const auto &p = Constants::OptionalPrograms[i];

        optional[i].enabled = s.enabled[p.keyEnabled];
        optional[i].id      = s.ids[p.keyId];
        optional[i].title   = s.titles[p.keyTitle];
    }

    // ===== Spec =====
    for (int i = 0; i < Constants::SpecCount; i++) {
        const auto &p = Constants::SpecPrograms[i];

        spec[i].enabled = s.enabled[p.keyEnabled];
        spec[i].id      = s.ids[p.keyId];
        spec[i].title   = s.titles[p.keyTitle];
    }

    // ===== Flag（チェックボックス）=====
    for (int i = 0; i < Constants::FlagCount; i++) {
        const auto &p = Constants::FlagSettings[i];
        checkBox[i] = s.enabled[p.keyEnabled];
    }

    // ===== その他設定 =====
    saveFolder     = s.saveFolder;
    audioExtension = s.audioExtension;
}

void RuntimeConfig::applyCommandLine(const QMap<QString, QString> &opts)
{
    // --save-folder
    if (opts.contains("save-folder"))
        saveFolder = opts["save-folder"];

    // --audio-ext
    if (opts.contains("audio-ext"))
        audioExtension = opts["audio-ext"];

    // --enable=xxx
    if (opts.contains("enable")) {
        QString key = opts["enable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = true;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = true;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = true;
    }

    // --disable=xxx
    if (opts.contains("disable")) {
        QString key = opts["disable"];

        for (int i = 0; i < Constants::EnglishCount; i++)
            if (Constants::EnglishPrograms[i].keyEnabled == key)
                english[i].enabled = false;

        for (int i = 0; i < Constants::OptionalCount; i++)
            if (Constants::OptionalPrograms[i].keyEnabled == key)
                optional[i].enabled = false;

        for (int i = 0; i < Constants::SpecCount; i++)
            if (Constants::SpecPrograms[i].keyEnabled == key)
                spec[i].enabled = false;
    }
}








#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class ScrambleDialog;
}

class ScrambleDialog : public QDialog {
    Q_OBJECT

public:
    explicit ScrambleDialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~ScrambleDialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::ScrambleDialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::OPT_PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateOptional(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};


#include "scrambledialog.h"
#include "ui_scrambledialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

ScrambleDialog::ScrambleDialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::ScrambleDialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4,
              ui->edit5, ui->edit6, ui->edit7, ui->edit8 };

    // ===== OptionalPrograms の ID を Settings から復元 =====
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++) {
        const auto &p = Constants::OptionalPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== フラグ復元 =====
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

ScrambleDialog::~ScrambleDialog()
{
    delete ui;
}

void ScrambleDialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
}

QString ScrambleDialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < OPT_PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = OPT_PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.optionals;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit *edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void ScrambleDialog::accept()
{
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; i++)
        updateOptional(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void ScrambleDialog::updateLabels()
{
    std::array<QLabel*, Constants::OPT_PRESET_SIZE> labels = {
        ui->label_2, ui->label_3, ui->label_4, ui->label_5,
        ui->label_6, ui->label_7, ui->label_8, ui->label_9
    };

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void ScrambleDialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {

            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void ScrambleDialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3] + "\n" +
        "５：" + titles[4] + "\n" +
        "６：" + titles[5] + "\n" +
        "７：" + titles[6] + "\n" +
        "８：" + titles[7];

    if (QMessageBox::question(this, tr("任意番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
            settings.optionals[i] = edits[i]->text();
    }
}

QString ScrambleDialog::updateOptional(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = OptionalPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}









#pragma once
#include <array>
#include <QDialog>
#include <QLineEdit>
#include "settings.h"
#include "constants.h"
#include "runtimeconfig.h"

namespace Ui {
class Settingsdialog;
}

class Settingsdialog : public QDialog {
    Q_OBJECT

public:
    explicit Settingsdialog(Settings& settings, RuntimeConfig* runtime, QWidget *parent = nullptr);
    ~Settingsdialog();

private slots:
    void pushbutton();
    void pushbutton_2();

private:
    Ui::Settingsdialog *ui;

    Settings& settings;
    RuntimeConfig* runtime;

    std::array<QLineEdit*, Constants::PRESET_SIZE> edits;

    QString scramble_set(QString opt, int index);
    QString updateSpecial(int index, const QString &currentText);
    void updateLabels();
    void applyFlags();
    void accept() override;
};



#include "settingsdialog.h"
#include "ui_settingsdialog.h"
#include "settings.h"
#include "utility.h"
#include <QMessageBox>

Settingsdialog::Settingsdialog(Settings& ini, RuntimeConfig* r, QWidget *parent)
    : QDialog(parent), ui(new Ui::Settingsdialog), settings(ini), runtime(r)
{
    ui->setupUi(this);

    edits = { ui->edit1, ui->edit2, ui->edit3, ui->edit4 };

    // ===== 特番（SpecPrograms）を Settings から復元 =====
    for (int i = 0; i < Constants::PRESET_SIZE; i++) {
        const auto &p = Constants::SpecPrograms[i];
        edits[i]->setText(settings.ids[p.keyId]);
    }

    ui->radioButton_9->setChecked(true);

    // ===== チェックボックスフラグ =====
    ui->checkBox->setChecked(settings.enabled[Constants::KEY_MULTI_GUI]);
    ui->checkBox_1->setChecked(settings.enabled[Constants::KEY_KOZA_SEPARATION]);
}

Settingsdialog::~Settingsdialog()
{
    delete ui;
}

void Settingsdialog::applyFlags()
{
    settings.enabled[Constants::KEY_KOZA_SEPARATION] = ui->checkBox_1->isChecked();
    settings.enabled[Constants::KEY_MULTI_GUI] = ui->checkBox->isChecked();
}

QString Settingsdialog::scramble_set(QString opt, int index)
{
    using namespace Constants;

    std::array<QAbstractButton*, 7> radios = {
        ui->radioButton, ui->radioButton_1, ui->radioButton_2,
        ui->radioButton_3, ui->radioButton_4, ui->radioButton_5,
        ui->radioButton_6
    };

    // プリセット適用
    for (int j = 0; j < PRESETS.size() && j < radios.size(); ++j) {
        if (radios[j]->isChecked()) {
            opt = PRESETS[j][index];
        }
    }

    // ユーザープリセット
    if (ui->radioButton_6->isChecked()) {
        auto opt1 = settings.specials;
        if (!opt1[index].isEmpty())
            opt = opt1[index];
    }

    QLineEdit* edit = edits[index];

    if (!ui->radioButton_9->isChecked()) {
        edit->setText(opt);
    } else {
        // name_map → id_map
        if (runtime->name_map.contains(edit->text()))
            opt = runtime->name_map[edit->text()];

        if (Utility::getProgram_name(edit->text()).isEmpty())
            edit->setText(opt);
    }

    return opt;
}

void Settingsdialog::accept()
{
    for (int i = 0; i < Constants::PRESET_SIZE; i++)
        updateSpecial(i, edits[i]->text());

    applyFlags();
    QDialog::accept();
}

void Settingsdialog::updateLabels()
{
    std::array<QLabel*, Constants::PRESET_SIZE> labels =
        { ui->label_2, ui->label_3, ui->label_4, ui->label_5 };

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        labels[i]->setText(Utility::getProgram_name(edits[i]->text()));
}

void Settingsdialog::pushbutton()
{
    const QStringList titles = runtime->name_map.keys();
    const QStringList ids    = runtime->name_map.values();

    for (int i = 0; i < Constants::PRESET_SIZE; ++i) {

        QString opt = edits[i]->text();

        if (!runtime->id_map.contains(opt)) {
            // タイトル部分一致
            for (int j = 0; j < titles.count(); ++j) {
                if (titles[j].contains(opt, Qt::CaseInsensitive)) {
                    opt = ids[j];
                    break;
                }
            }

            // ID 部分一致
            if (!runtime->id_map.contains(opt)) {
                for (int j = 0; j < ids.count(); ++j) {
                    if (ids[j].contains(opt, Qt::CaseInsensitive)) {
                        opt = ids[j];
                        break;
                    }
                }
            }
        }

        opt = scramble_set(opt, i);
        edits[i]->setText(opt);
    }

    ui->radioButton_9->setChecked(true);
    updateLabels();
}

void Settingsdialog::pushbutton_2()
{
    QStringList titles;

    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        titles << runtime->id_map.value(edits[i]->text());

    QString msg =
        QStringLiteral("下記内容で上書きします。保存しますか？\n") +
        "１：" + titles[0] + "\n" +
        "２：" + titles[1] + "\n" +
        "３：" + titles[2] + "\n" +
        "４：" + titles[3];

    if (QMessageBox::question(this, tr("特別番組設定保存"), msg) == QMessageBox::Yes) {
        for (int i = 0; i < Constants::PRESET_SIZE; ++i)
            settings.specials[i] = edits[i]->text();
    }
}

QString Settingsdialog::updateSpecial(int index, const QString &currentText)
{
    using namespace Constants;

    QString newValue = scramble_set(currentText, index);
    const auto &p = SpecPrograms[index];

    QString oldValue = settings.ids[p.keyId];

    if (oldValue == newValue)
        return newValue;

    // ID 更新
    settings.ids[p.keyId] = newValue;

    // enabled を false にする
    settings.enabled[p.keyEnabled] = false;

    // タイトル更新
    if (!runtime->id_map.contains(newValue))
        settings.titles[p.keyTitle] = Utility::getProgram_name(newValue);
    else
        settings.titles[p.keyTitle] = runtime->id_map[newValue];

    settings.save();
    return newValue;
}






void MainWindow::restoreGui()
{
    auto &s = Settings::instance();

    // geometry 復元
    if (!s.mainWindowGeometry.isEmpty()) {
        restoreGeometry(s.mainWindowGeometry);
    }

    // ===== English =====
    for (const auto &p : Constants::EnglishPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);
            btn->setText(p.titleDefault);   // 固定タイトル
        }
    }

    // ===== Optional =====
    for (const auto &p : Constants::OptionalPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Spec =====
    for (const auto &p : Constants::SpecPrograms) {
        if (auto btn = findChild<QToolButton*>(p.objectName)) {
            btn->setChecked(s.enabled[p.keyEnabled]);

            // INI に保存されたタイトルを復元
            if (!p.keyTitle.isEmpty())
                btn->setText(s.titles[p.keyTitle]);
        }
    }

    // ===== Flag（チェックボックス）=====
    for (const auto &p : Constants::FlagSettings) {
        if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
            cb->setChecked(s.enabled[p.keyEnabled]);
            // ラベルは UI 側の固定値を使うので setText は不要
        }
    }
}

void MainWindow::saveGui()
{
    auto &s = Settings::instance();

    // geometry 保存
    s.saveMainWindow(saveGeometry());

    // enabled の書き戻し
    for (const auto &p : Constants::EnglishPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::OptionalPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::SpecPrograms) {
        if (!p.objectName.isEmpty()) {
            if (auto btn = findChild<QToolButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = btn->isChecked();
            }
        }
    }

    for (const auto &p : Constants::FlagSettings) {
        if (!p.objectName.isEmpty()) {
            if (auto cb = findChild<QAbstractButton*>(p.objectName)) {
                s.enabled[p.keyEnabled] = cb->isChecked();
            }
        }
    }

    // 最後に settings.ini へ保存
    s.save();
}





// Settings.h

#pragma once
#include <QString>
#include <QSettings>
#include <QMap>
#include <QVector>
#include <QByteArray>
#include "constants.h"

class Settings
{
public:
    static Settings& instance();

    void load();
    void save();

    // ===== MainWindow / MessageWindow =====
    void loadMainWindow();
    void saveMainWindow(const QByteArray &geometry);

    void loadMessageWindow();
    void saveMessageWindow(const QByteArray &geometry);

    // ===== 基本設定 =====
    QString audioExtension;
    QString ffmpegFolder;
    QString saveFolder;

    // ===== ProgramEntry の値（enabled / id / title）=====
    // keyEnabled → enabled
    QMap<QString, bool> enabled;

    // keyId → id
    QMap<QString, QString> ids;

    // keyTitle → title
    QMap<QString, QString> titles;

    // ===== optional / spec のプリセット =====
    std::array<QString, Constants::OPT_PRESET_SIZE> optionals;
    std::array<QString, Constants::PRESET_SIZE> specials;

    // ===== geometry =====
    QByteArray mainWindowGeometry;
    QByteArray messageWindowGeometry;

    // ===== CustomizeDialog =====
    QString titleFormat[Constants::ITEM_COUNT];
    QString fileNameFormat[Constants::ITEM_COUNT];

    static QString getTitleFormat(int index);
    static QString getFileNameFormat(int index);

    static void setTitleFormatValue(int index, const QString &value);
    static void setFileNameFormatValue(int index, const QString &value);

    // ===== CheckBox flags =====
    static bool tagSpaceFlag();
    static bool nameSpaceFlag();
    static bool multiGuiFlag();
    static bool kozaSeparationFlag();

    static void setTagSpaceFlag(bool flag);
    static void setNameSpaceFlag(bool flag);
    static void setMultiGuiFlag(bool flag);
    static void setKozaSeparationFlag(bool flag);

private:
    Settings();
    Settings(const Settings&) = delete;
    Settings& operator=(const Settings&) = delete;

    // 内部ヘルパー
    void loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
    void saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini);
};


//settings.cpp
#include "settings.h"
#include <QSettings>

Settings::Settings()
{
}

Settings& Settings::instance()
{
    static Settings inst;
    return inst;
}

void Settings::load()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    // ===== MainWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて読み込む
    for (const auto &p : Constants::EnglishPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) loadProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     loadProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     loadProgramEntry(p, ini);

    // audioExtension
    audioExtension = ini.value(Constants::KEY_AudioExtension,
                               Constants::DEFAULT_AudioExtension).toString();

    // saveFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_SaveFolder);
        saveFolder = v.isValid() ? v.toString() : QString();
    }

    // ffmpegFolder（null 許容）
    {
        QVariant v = ini.value(Constants::KEY_FfmpegFolder);
        ffmpegFolder = v.isValid() ? v.toString() : QString();
    }

    mainWindowGeometry = ini.value("geometry").toByteArray();

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    messageWindowGeometry = ini.value("geometry").toByteArray();
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        optionals[i] = ini.value(QString("optional%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        specials[i] = ini.value(QString("special%1").arg(i + 1), "").toString();
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        titleFormat[i] = ini.value(t.key, t.defaultValue).toString();

        const auto &f = Constants::FILENAME_ITEMS[i];
        fileNameFormat[i] = ini.value(f.key, f.defaultValue).toString();
    }
    ini.endGroup();
}

void Settings::save()
{
    QSettings ini(Constants::IniFileName, QSettings::IniFormat);

    ini.beginGroup(Constants::SETTING_GROUP_MainWindow);

    // English / Optional / Spec / Flag をすべて保存
    for (const auto &p : Constants::EnglishPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::OptionalPrograms) saveProgramEntry(p, ini);
    for (const auto &p : Constants::SpecPrograms)     saveProgramEntry(p, ini);
    for (const auto &p : Constants::FlagSettings)     saveProgramEntry(p, ini);

    ini.setValue(Constants::KEY_AudioExtension, audioExtension);

    if (saveFolder.isNull()) ini.remove(Constants::KEY_SaveFolder);
    else ini.setValue(Constants::KEY_SaveFolder, saveFolder);

    if (ffmpegFolder.isNull()) ini.remove(Constants::KEY_FfmpegFolder);
    else ini.setValue(Constants::KEY_FfmpegFolder, ffmpegFolder);

    ini.setValue("geometry", mainWindowGeometry);

    ini.endGroup();

    // ===== MessageWindow =====
    ini.beginGroup(Constants::SETTING_GROUP_MessageWindow);
    ini.setValue("geometry", messageWindowGeometry);
    ini.endGroup();

    // ===== ScrambleDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_ScrambleDialog);
    for (int i = 0; i < Constants::OPT_PRESET_SIZE; ++i)
        ini.setValue(QString("optional%1").arg(i + 1), optionals[i]);
    ini.endGroup();

    // ===== Settingsdialog =====
    ini.beginGroup(Constants::SETTING_GROUP_Settingsdialog);
    for (int i = 0; i < Constants::PRESET_SIZE; ++i)
        ini.setValue(QString("special%1").arg(i + 1), specials[i]);
    ini.endGroup();

    // ===== CustomizeDialog =====
    ini.beginGroup(Constants::SETTING_GROUP_CustomizeDialog);
    for (int i = 0; i < Constants::ITEM_COUNT; ++i) {
        const auto &t = Constants::TITLE_ITEMS[i];
        ini.setValue(t.key, titleFormat[i]);

        const auto &f = Constants::FILENAME_ITEMS[i];
        ini.setValue(f.key, fileNameFormat[i]);
    }
    ini.endGroup();
}

/* ============================================================
 * ProgramEntry 読み込み
 * ============================================================ */
void Settings::loadProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    // enabled
    enabled[p.keyEnabled] =
        ini.value(p.keyEnabled, p.enabledDefault).toBool();

    // id
    if (!p.keyId.isEmpty())
        ids[p.keyId] = ini.value(p.keyId, p.idDefault).toString();

    // title
    if (!p.keyTitle.isEmpty())
        titles[p.keyTitle] = ini.value(p.keyTitle, p.titleDefault).toString();
}

/* ============================================================
 * ProgramEntry 保存
 * ============================================================ */
void Settings::saveProgramEntry(const Constants::ProgramEntry &p, QSettings &ini)
{
    ini.setValue(p.keyEnabled, enabled[p.keyEnabled]);

    if (!p.keyId.isEmpty())
        ini.setValue(p.keyId, ids[p.keyId]);

    if (!p.keyTitle.isEmpty())
        ini.setValue(p.keyTitle, titles[p.keyTitle]);
}






class Settings {
public:
    static Settings& instance();

    // 既存のマップ
    QMap<QString, bool> englishEnabled;
    QMap<QString, bool> optionalEnabled;
    QMap<QString, bool> specEnabled;
    QMap<QString, bool> checkBoxEnabled;

    // ★ 追加：横断 enabled キャッシュ（INI に保存しない）
    QMap<QString, bool> enabled;

    void buildUnifiedEnabled();   // load() の後に呼ぶ
    void syncEnabledBack();       // save() の前に呼ぶ

    // ...
};


void Settings::buildUnifiedEnabled()
{
    enabled.clear();

    // English
    for (const auto& p : Constants::EnglishPrograms) {
        enabled[p.key] = englishEnabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        enabled[p.keyEnabled] = optionalEnabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        enabled[p.keyEnabled] = specEnabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        enabled[c.keyEnabled] = checkBoxEnabled[c.keyEnabled];
    }
}


void Settings::syncEnabledBack()
{
    // English
    for (const auto& p : Constants::EnglishPrograms) {
        englishEnabled[p.key] = enabled[p.key];
    }

    // Optional
    for (const auto& p : Constants::OptionalPrograms) {
        optionalEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // Spec
    for (const auto& p : Constants::SpecPrograms) {
        specEnabled[p.keyEnabled] = enabled[p.keyEnabled];
    }

    // CheckBox
    for (const auto& c : Constants::CheckBoxSettings) {
        checkBoxEnabled[c.keyEnabled] = enabled[c.keyEnabled];
    }
}



buildUnifiedEnabled();


syncEnabledBack();


QMap<QString, QString> objectToKey;


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    using namespace Constants;

    // English
    for (const auto& p : EnglishPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.key;
    }

    // Optional
    for (const auto& p : OptionalPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // Spec
    for (const auto& p : SpecPrograms) {
        if (!p.objectName.isEmpty())
            objectToKey[p.objectName] = p.keyEnabled;
    }

    // CheckBox
    for (const auto& c : CheckBoxSettings) {
        if (!c.objectName.isEmpty())
            objectToKey[c.objectName] = c.keyEnabled;
    }
}


void MainWindow::toggled(bool checked)
{
    auto* button = qobject_cast<QToolButton*>(sender());
    if (!button) return;

    const QString obj = button->objectName();

    // ★ 横断 enabled に書き込むだけ
    if (objectToKey.contains(obj)) {
        const QString key = objectToKey.value(obj);
        settings.enabled[key] = checked;
    }

    // UI のチェックマーク処理
    QString text = button->text();
    const QString check = QString::fromUtf8("✓ ");

    if (text.startsWith(check))
        text.remove(0, check.size());

    if (checked)
        text.prepend(check);

    button->setText(text);
}
